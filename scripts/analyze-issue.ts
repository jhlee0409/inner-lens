/**
 * inner-lens Analysis Engine v2
 * Enhanced with 2025 best practices:
 * - Chain-of-Thought reasoning
 * - Structured JSON output
 * - Context-aware file selection
 * - Rate limiting with retry
 * - Improved security
 */

import { generateText, generateObject } from 'ai';
import { anthropic } from '@ai-sdk/anthropic';
import { openai } from '@ai-sdk/openai';
import { google } from '@ai-sdk/google';
import { Octokit } from '@octokit/rest';
import { z } from 'zod';
import * as fs from 'fs';
import * as path from 'path';
import { maskSensitiveData } from '../src/utils/masking.js';

// ============================================
// Type Definitions
// ============================================

type AIProvider = 'anthropic' | 'openai' | 'google';

// Supported languages for analysis output
type OutputLanguage = 'en' | 'ko' | 'ja' | 'zh' | 'es' | 'de' | 'fr' | 'pt';

const LANGUAGE_NAMES: Record<OutputLanguage, string> = {
  en: 'English',
  ko: 'í•œêµ­ì–´ (Korean)',
  ja: 'æ—¥æœ¬èª (Japanese)',
  zh: 'ä¸­æ–‡ (Chinese)',
  es: 'EspaÃ±ol (Spanish)',
  de: 'Deutsch (German)',
  fr: 'FranÃ§ais (French)',
  pt: 'PortuguÃªs (Portuguese)',
};

// i18n strings for comment templates
interface I18nStrings {
  analysisTitle: string;
  severity: string;
  category: string;
  confidence: string;
  rootCause: string;
  suggestedFix: string;
  prevention: string;
  additionalNotes: string;
  affectedFiles: string;
  codeChanges: string;
  before: string;
  after: string;
  analysisMetadata: string;
  provider: string;
  model: string;
  filesAnalyzed: string;
  timestamp: string;
  analysis: string;
  generatedBy: string;
  verifyBeforeApplying: string;
  // Invalid report
  reportStatus: string;
  insufficientInfo: string;
  unableToAnalyze: string;
  insufficientInfoReason: string;
  whatWeNeed: string;
  errorMessages: string;
  stepsToReproduce: string;
  expectedVsActual: string;
  consoleLogs: string;
  nextSteps: string;
  updateIssue: string;
  submitNewReport: string;
  // Classification
  classification: string;
  analysisResult: string;
  codeVerification: string;
  noBugFound: string;
  possibleExplanation: string;
  recommendation: string;
  featureRequestNote: string;
  expectedBehavior: string;
  workingAsDesigned: string;
  unableToConfirm: string;
  whatThisMeans: string;
  bugMayExist: string;
  environmentSpecific: string;
  moreInfoNeeded: string;
  suggestedNextSteps: string;
  provideConsoleLogs: string;
  shareStepsToReproduce: string;
  includeExactError: string;
  bugFoundInCode: string;
  yes: string;
  no: string;
  // Report types
  confirmedBug: string;
  notABug: string;
  featureRequest: string;
  improvementSuggestion: string;
  cannotVerify: string;
  needsMoreInfo: string;
  // Categories
  runtimeError: string;
  logicError: string;
  performanceIssue: string;
  securityIssue: string;
  uiUxIssue: string;
  configurationIssue: string;
  invalidReport: string;
  unknown: string;
}

const I18N: Record<OutputLanguage, I18nStrings> = {
  en: {
    analysisTitle: 'inner-lens Analysis',
    severity: 'Severity',
    category: 'Category',
    confidence: 'Confidence',
    rootCause: 'Root Cause',
    suggestedFix: 'Suggested Fix',
    prevention: 'Prevention',
    additionalNotes: 'Additional Notes',
    affectedFiles: 'Affected Files',
    codeChanges: 'Code Changes',
    before: 'Before',
    after: 'After',
    analysisMetadata: 'Analysis Metadata',
    provider: 'Provider',
    model: 'Model',
    filesAnalyzed: 'Files Analyzed',
    timestamp: 'Timestamp',
    analysis: 'Analysis',
    generatedBy: 'This analysis was generated by',
    verifyBeforeApplying: 'Always verify suggestions before applying.',
    reportStatus: 'Report Status',
    insufficientInfo: 'INSUFFICIENT INFORMATION',
    unableToAnalyze: 'Unable to Analyze',
    insufficientInfoReason: 'This bug report does not contain enough information for automated analysis.',
    whatWeNeed: 'What We Need',
    errorMessages: 'Error messages or stack traces',
    stepsToReproduce: 'Steps to reproduce',
    expectedVsActual: 'Expected vs actual behavior',
    consoleLogs: 'Console logs',
    nextSteps: 'Next Steps',
    updateIssue: 'Update this issue with more details',
    submitNewReport: 'Submit a new report with the inner-lens widget (ensure console logging is enabled)',
    classification: 'Classification',
    analysisResult: 'Analysis Result',
    codeVerification: 'Code Verification',
    noBugFound: 'No bug found in code',
    possibleExplanation: 'Possible Explanation',
    recommendation: 'Recommendation',
    featureRequestNote: 'This appears to be a feature request rather than a bug report.',
    expectedBehavior: 'Expected Behavior',
    workingAsDesigned: 'The reported behavior appears to be working as designed.',
    unableToConfirm: 'Unable to Confirm',
    whatThisMeans: 'What this means',
    bugMayExist: 'The bug may exist in code we didn\'t analyze',
    environmentSpecific: 'The issue may be environment-specific',
    moreInfoNeeded: 'More information may be needed',
    suggestedNextSteps: 'Suggested next steps',
    provideConsoleLogs: 'Provide console logs with the error',
    shareStepsToReproduce: 'Share steps to reproduce',
    includeExactError: 'Include the exact error message',
    bugFoundInCode: 'Bug Found in Code',
    yes: 'Yes',
    no: 'No',
    confirmedBug: 'Confirmed Bug',
    notABug: 'Not a Bug',
    featureRequest: 'Feature Request',
    improvementSuggestion: 'Improvement Suggestion',
    cannotVerify: 'Cannot Verify',
    needsMoreInfo: 'Needs More Info',
    runtimeError: 'Runtime Error',
    logicError: 'Logic Error',
    performanceIssue: 'Performance Issue',
    securityIssue: 'Security Issue',
    uiUxIssue: 'UI/UX Issue',
    configurationIssue: 'Configuration Issue',
    invalidReport: 'Invalid Report',
    unknown: 'Unknown',
  },
  ko: {
    analysisTitle: 'inner-lens ë¶„ì„',
    severity: 'ì‹¬ê°ë„',
    category: 'ì¹´í…Œê³ ë¦¬',
    confidence: 'ì‹ ë¢°ë„',
    rootCause: 'ê·¼ë³¸ ì›ì¸',
    suggestedFix: 'ìˆ˜ì • ì œì•ˆ',
    prevention: 'ì˜ˆë°© ë°©ë²•',
    additionalNotes: 'ì¶”ê°€ ì°¸ê³ ì‚¬í•­',
    affectedFiles: 'ì˜í–¥ë°›ëŠ” íŒŒì¼',
    codeChanges: 'ì½”ë“œ ë³€ê²½ì‚¬í•­',
    before: 'ë³€ê²½ ì „',
    after: 'ë³€ê²½ í›„',
    analysisMetadata: 'ë¶„ì„ ë©”íƒ€ë°ì´í„°',
    provider: 'ì œê³µì',
    model: 'ëª¨ë¸',
    filesAnalyzed: 'ë¶„ì„ëœ íŒŒì¼ ìˆ˜',
    timestamp: 'íƒ€ì„ìŠ¤íƒ¬í”„',
    analysis: 'ë¶„ì„',
    generatedBy: 'ì´ ë¶„ì„ì€ ë‹¤ìŒì— ì˜í•´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤:',
    verifyBeforeApplying: 'ì ìš©í•˜ê¸° ì „ì— í•­ìƒ ì œì•ˆ ì‚¬í•­ì„ ê²€ì¦í•˜ì„¸ìš”.',
    reportStatus: 'ë¦¬í¬íŠ¸ ìƒíƒœ',
    insufficientInfo: 'ì •ë³´ ë¶€ì¡±',
    unableToAnalyze: 'ë¶„ì„ ë¶ˆê°€',
    insufficientInfoReason: 'ì´ ë²„ê·¸ ë¦¬í¬íŠ¸ì—ëŠ” ìë™ ë¶„ì„ì„ ìœ„í•œ ì¶©ë¶„í•œ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.',
    whatWeNeed: 'í•„ìš”í•œ ì •ë³´',
    errorMessages: 'ì—ëŸ¬ ë©”ì‹œì§€ ë˜ëŠ” ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤',
    stepsToReproduce: 'ì¬í˜„ ë‹¨ê³„',
    expectedVsActual: 'ì˜ˆìƒ ë™ì‘ vs ì‹¤ì œ ë™ì‘',
    consoleLogs: 'ì½˜ì†” ë¡œê·¸',
    nextSteps: 'ë‹¤ìŒ ë‹¨ê³„',
    updateIssue: 'ì´ ì´ìŠˆì— ë” ìì„¸í•œ ë‚´ìš©ì„ ì¶”ê°€í•´ ì£¼ì„¸ìš”',
    submitNewReport: 'inner-lens ìœ„ì ¯ìœ¼ë¡œ ìƒˆ ë¦¬í¬íŠ¸ë¥¼ ì œì¶œí•´ ì£¼ì„¸ìš” (ì½˜ì†” ë¡œê¹… í™œì„±í™” í•„ìš”)',
    classification: 'ë¶„ë¥˜',
    analysisResult: 'ë¶„ì„ ê²°ê³¼',
    codeVerification: 'ì½”ë“œ ê²€ì¦',
    noBugFound: 'ì½”ë“œì—ì„œ ë²„ê·¸ë¥¼ ì°¾ì§€ ëª»í•¨',
    possibleExplanation: 'ê°€ëŠ¥í•œ ì„¤ëª…',
    recommendation: 'ê¶Œì¥ ì‚¬í•­',
    featureRequestNote: 'ì´ê²ƒì€ ë²„ê·¸ ë¦¬í¬íŠ¸ê°€ ì•„ë‹Œ ê¸°ëŠ¥ ìš”ì²­ìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤.',
    expectedBehavior: 'ì˜ˆìƒ ë™ì‘',
    workingAsDesigned: 'ë¦¬í¬íŠ¸ëœ ë™ì‘ì€ ì„¤ê³„ëœ ëŒ€ë¡œ ì‘ë™í•˜ê³  ìˆìŠµë‹ˆë‹¤.',
    unableToConfirm: 'í™•ì¸ ë¶ˆê°€',
    whatThisMeans: 'ì´ê²ƒì´ ì˜ë¯¸í•˜ëŠ” ê²ƒ',
    bugMayExist: 'ë¶„ì„í•˜ì§€ ì•Šì€ ì½”ë“œì— ë²„ê·¸ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤',
    environmentSpecific: 'í™˜ê²½ì— ë”°ë¥¸ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤',
    moreInfoNeeded: 'ì¶”ê°€ ì •ë³´ê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
    suggestedNextSteps: 'ê¶Œì¥ ë‹¤ìŒ ë‹¨ê³„',
    provideConsoleLogs: 'ì—ëŸ¬ê°€ í¬í•¨ëœ ì½˜ì†” ë¡œê·¸ë¥¼ ì œê³µí•´ ì£¼ì„¸ìš”',
    shareStepsToReproduce: 'ì¬í˜„ ë‹¨ê³„ë¥¼ ê³µìœ í•´ ì£¼ì„¸ìš”',
    includeExactError: 'ì •í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ í¬í•¨í•´ ì£¼ì„¸ìš”',
    bugFoundInCode: 'ì½”ë“œì—ì„œ ë²„ê·¸ ë°œê²¬',
    yes: 'ì˜ˆ',
    no: 'ì•„ë‹ˆì˜¤',
    confirmedBug: 'ë²„ê·¸ í™•ì¸ë¨',
    notABug: 'ë²„ê·¸ ì•„ë‹˜',
    featureRequest: 'ê¸°ëŠ¥ ìš”ì²­',
    improvementSuggestion: 'ê°œì„  ì œì•ˆ',
    cannotVerify: 'í™•ì¸ ë¶ˆê°€',
    needsMoreInfo: 'ì¶”ê°€ ì •ë³´ í•„ìš”',
    runtimeError: 'ëŸ°íƒ€ì„ ì—ëŸ¬',
    logicError: 'ë¡œì§ ì—ëŸ¬',
    performanceIssue: 'ì„±ëŠ¥ ì´ìŠˆ',
    securityIssue: 'ë³´ì•ˆ ì´ìŠˆ',
    uiUxIssue: 'UI/UX ì´ìŠˆ',
    configurationIssue: 'ì„¤ì • ì´ìŠˆ',
    invalidReport: 'ìœ íš¨í•˜ì§€ ì•Šì€ ë¦¬í¬íŠ¸',
    unknown: 'ì•Œ ìˆ˜ ì—†ìŒ',
  },
  ja: {
    analysisTitle: 'inner-lens åˆ†æ',
    severity: 'æ·±åˆ»åº¦',
    category: 'ã‚«ãƒ†ã‚´ãƒª',
    confidence: 'ä¿¡é ¼åº¦',
    rootCause: 'æ ¹æœ¬åŸå› ',
    suggestedFix: 'ä¿®æ­£ææ¡ˆ',
    prevention: 'äºˆé˜²ç­–',
    additionalNotes: 'è¿½åŠ ãƒ¡ãƒ¢',
    affectedFiles: 'å½±éŸ¿ã‚’å—ã‘ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«',
    codeChanges: 'ã‚³ãƒ¼ãƒ‰å¤‰æ›´',
    before: 'å¤‰æ›´å‰',
    after: 'å¤‰æ›´å¾Œ',
    analysisMetadata: 'åˆ†æãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿',
    provider: 'ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼',
    model: 'ãƒ¢ãƒ‡ãƒ«',
    filesAnalyzed: 'åˆ†æãƒ•ã‚¡ã‚¤ãƒ«æ•°',
    timestamp: 'ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—',
    analysis: 'åˆ†æ',
    generatedBy: 'ã“ã®åˆ†æã¯ä»¥ä¸‹ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã¾ã—ãŸ:',
    verifyBeforeApplying: 'é©ç”¨å‰ã«å¿…ãšææ¡ˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
    reportStatus: 'ãƒ¬ãƒãƒ¼ãƒˆçŠ¶æ…‹',
    insufficientInfo: 'æƒ…å ±ä¸è¶³',
    unableToAnalyze: 'åˆ†æä¸å¯',
    insufficientInfoReason: 'ã“ã®ãƒã‚°ãƒ¬ãƒãƒ¼ãƒˆã«ã¯è‡ªå‹•åˆ†æã«ååˆ†ãªæƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“ã€‚',
    whatWeNeed: 'å¿…è¦ãªæƒ…å ±',
    errorMessages: 'ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¾ãŸã¯ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹',
    stepsToReproduce: 'å†ç¾æ‰‹é †',
    expectedVsActual: 'æœŸå¾…ã•ã‚Œã‚‹å‹•ä½œ vs å®Ÿéš›ã®å‹•ä½œ',
    consoleLogs: 'ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°',
    nextSteps: 'æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—',
    updateIssue: 'ã“ã® Issue ã«è©³ç´°ã‚’è¿½åŠ ã—ã¦ãã ã•ã„',
    submitNewReport: 'inner-lens ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã§æ–°ã—ã„ãƒ¬ãƒãƒ¼ãƒˆã‚’æå‡ºã—ã¦ãã ã•ã„',
    classification: 'åˆ†é¡',
    analysisResult: 'åˆ†æçµæœ',
    codeVerification: 'ã‚³ãƒ¼ãƒ‰æ¤œè¨¼',
    noBugFound: 'ã‚³ãƒ¼ãƒ‰ã«ãƒã‚°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
    possibleExplanation: 'è€ƒãˆã‚‰ã‚Œã‚‹èª¬æ˜',
    recommendation: 'æ¨å¥¨äº‹é …',
    featureRequestNote: 'ã“ã‚Œã¯ãƒã‚°ãƒ¬ãƒãƒ¼ãƒˆã§ã¯ãªãæ©Ÿèƒ½ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã‚ˆã†ã§ã™ã€‚',
    expectedBehavior: 'æœŸå¾…ã•ã‚Œã‚‹å‹•ä½œ',
    workingAsDesigned: 'å ±å‘Šã•ã‚ŒãŸå‹•ä½œã¯è¨­è¨ˆé€šã‚Šã«å‹•ä½œã—ã¦ã„ã¾ã™ã€‚',
    unableToConfirm: 'ç¢ºèªä¸å¯',
    whatThisMeans: 'ã“ã‚ŒãŒæ„å‘³ã™ã‚‹ã“ã¨',
    bugMayExist: 'åˆ†æã—ã¦ã„ãªã„ã‚³ãƒ¼ãƒ‰ã«ãƒã‚°ãŒå­˜åœ¨ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
    environmentSpecific: 'ç’°å¢ƒå›ºæœ‰ã®å•é¡Œã‹ã‚‚ã—ã‚Œã¾ã›ã‚“',
    moreInfoNeeded: 'è¿½åŠ æƒ…å ±ãŒå¿…è¦ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“',
    suggestedNextSteps: 'æ¨å¥¨ã•ã‚Œã‚‹æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—',
    provideConsoleLogs: 'ã‚¨ãƒ©ãƒ¼ã‚’å«ã‚€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’æä¾›ã—ã¦ãã ã•ã„',
    shareStepsToReproduce: 'å†ç¾æ‰‹é †ã‚’å…±æœ‰ã—ã¦ãã ã•ã„',
    includeExactError: 'æ­£ç¢ºãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å«ã‚ã¦ãã ã•ã„',
    bugFoundInCode: 'ã‚³ãƒ¼ãƒ‰ã§ãƒã‚°ã‚’ç™ºè¦‹',
    yes: 'ã¯ã„',
    no: 'ã„ã„ãˆ',
    confirmedBug: 'ãƒã‚°ç¢ºèªæ¸ˆã¿',
    notABug: 'ãƒã‚°ã§ã¯ãªã„',
    featureRequest: 'æ©Ÿèƒ½ãƒªã‚¯ã‚¨ã‚¹ãƒˆ',
    improvementSuggestion: 'æ”¹å–„ææ¡ˆ',
    cannotVerify: 'ç¢ºèªä¸å¯',
    needsMoreInfo: 'è¿½åŠ æƒ…å ±ãŒå¿…è¦',
    runtimeError: 'ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¨ãƒ©ãƒ¼',
    logicError: 'ãƒ­ã‚¸ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼',
    performanceIssue: 'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ',
    securityIssue: 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å•é¡Œ',
    uiUxIssue: 'UI/UXå•é¡Œ',
    configurationIssue: 'è¨­å®šå•é¡Œ',
    invalidReport: 'ç„¡åŠ¹ãªãƒ¬ãƒãƒ¼ãƒˆ',
    unknown: 'ä¸æ˜',
  },
  zh: {
    analysisTitle: 'inner-lens åˆ†æ',
    severity: 'ä¸¥é‡ç¨‹åº¦',
    category: 'ç±»åˆ«',
    confidence: 'ç½®ä¿¡åº¦',
    rootCause: 'æ ¹æœ¬åŸå› ',
    suggestedFix: 'å»ºè®®ä¿®å¤',
    prevention: 'é¢„é˜²æªæ–½',
    additionalNotes: 'é™„åŠ è¯´æ˜',
    affectedFiles: 'å—å½±å“çš„æ–‡ä»¶',
    codeChanges: 'ä»£ç æ›´æ”¹',
    before: 'ä¿®æ”¹å‰',
    after: 'ä¿®æ”¹å',
    analysisMetadata: 'åˆ†æå…ƒæ•°æ®',
    provider: 'æä¾›è€…',
    model: 'æ¨¡å‹',
    filesAnalyzed: 'åˆ†æçš„æ–‡ä»¶æ•°',
    timestamp: 'æ—¶é—´æˆ³',
    analysis: 'åˆ†æ',
    generatedBy: 'æ­¤åˆ†æç”±ä»¥ä¸‹ç”Ÿæˆ:',
    verifyBeforeApplying: 'åº”ç”¨å‰è¯·åŠ¡å¿…éªŒè¯å»ºè®®ã€‚',
    reportStatus: 'æŠ¥å‘ŠçŠ¶æ€',
    insufficientInfo: 'ä¿¡æ¯ä¸è¶³',
    unableToAnalyze: 'æ— æ³•åˆ†æ',
    insufficientInfoReason: 'æ­¤é”™è¯¯æŠ¥å‘Šæ²¡æœ‰è¶³å¤Ÿçš„ä¿¡æ¯è¿›è¡Œè‡ªåŠ¨åˆ†æã€‚',
    whatWeNeed: 'æ‰€éœ€ä¿¡æ¯',
    errorMessages: 'é”™è¯¯æ¶ˆæ¯æˆ–å †æ ˆè·Ÿè¸ª',
    stepsToReproduce: 'é‡ç°æ­¥éª¤',
    expectedVsActual: 'é¢„æœŸè¡Œä¸º vs å®é™…è¡Œä¸º',
    consoleLogs: 'æ§åˆ¶å°æ—¥å¿—',
    nextSteps: 'ä¸‹ä¸€æ­¥',
    updateIssue: 'è¯·æ›´æ–°æ­¤ Issue æ·»åŠ æ›´å¤šè¯¦æƒ…',
    submitNewReport: 'è¯·ä½¿ç”¨ inner-lens å°éƒ¨ä»¶æäº¤æ–°æŠ¥å‘Š',
    classification: 'åˆ†ç±»',
    analysisResult: 'åˆ†æç»“æœ',
    codeVerification: 'ä»£ç éªŒè¯',
    noBugFound: 'ä»£ç ä¸­æœªå‘ç°é”™è¯¯',
    possibleExplanation: 'å¯èƒ½çš„è§£é‡Š',
    recommendation: 'å»ºè®®',
    featureRequestNote: 'è¿™ä¼¼ä¹æ˜¯åŠŸèƒ½è¯·æ±‚è€Œéé”™è¯¯æŠ¥å‘Šã€‚',
    expectedBehavior: 'é¢„æœŸè¡Œä¸º',
    workingAsDesigned: 'æŠ¥å‘Šçš„è¡Œä¸ºæŒ‰è®¾è®¡æ­£å¸¸å·¥ä½œã€‚',
    unableToConfirm: 'æ— æ³•ç¡®è®¤',
    whatThisMeans: 'è¿™æ„å‘³ç€',
    bugMayExist: 'é”™è¯¯å¯èƒ½å­˜åœ¨äºæˆ‘ä»¬æœªåˆ†æçš„ä»£ç ä¸­',
    environmentSpecific: 'é—®é¢˜å¯èƒ½ä¸ç¯å¢ƒç›¸å…³',
    moreInfoNeeded: 'å¯èƒ½éœ€è¦æ›´å¤šä¿¡æ¯',
    suggestedNextSteps: 'å»ºè®®çš„ä¸‹ä¸€æ­¥',
    provideConsoleLogs: 'è¯·æä¾›åŒ…å«é”™è¯¯çš„æ§åˆ¶å°æ—¥å¿—',
    shareStepsToReproduce: 'è¯·åˆ†äº«é‡ç°æ­¥éª¤',
    includeExactError: 'è¯·åŒ…å«ç¡®åˆ‡çš„é”™è¯¯æ¶ˆæ¯',
    bugFoundInCode: 'åœ¨ä»£ç ä¸­å‘ç°é”™è¯¯',
    yes: 'æ˜¯',
    no: 'å¦',
    confirmedBug: 'å·²ç¡®è®¤é”™è¯¯',
    notABug: 'éé”™è¯¯',
    featureRequest: 'åŠŸèƒ½è¯·æ±‚',
    improvementSuggestion: 'æ”¹è¿›å»ºè®®',
    cannotVerify: 'æ— æ³•éªŒè¯',
    needsMoreInfo: 'éœ€è¦æ›´å¤šä¿¡æ¯',
    runtimeError: 'è¿è¡Œæ—¶é”™è¯¯',
    logicError: 'é€»è¾‘é”™è¯¯',
    performanceIssue: 'æ€§èƒ½é—®é¢˜',
    securityIssue: 'å®‰å…¨é—®é¢˜',
    uiUxIssue: 'UI/UXé—®é¢˜',
    configurationIssue: 'é…ç½®é—®é¢˜',
    invalidReport: 'æ— æ•ˆæŠ¥å‘Š',
    unknown: 'æœªçŸ¥',
  },
  es: {
    analysisTitle: 'AnÃ¡lisis de inner-lens',
    severity: 'Severidad',
    category: 'CategorÃ­a',
    confidence: 'Confianza',
    rootCause: 'Causa RaÃ­z',
    suggestedFix: 'CorrecciÃ³n Sugerida',
    prevention: 'PrevenciÃ³n',
    additionalNotes: 'Notas Adicionales',
    affectedFiles: 'Archivos Afectados',
    codeChanges: 'Cambios de CÃ³digo',
    before: 'Antes',
    after: 'DespuÃ©s',
    analysisMetadata: 'Metadatos del AnÃ¡lisis',
    provider: 'Proveedor',
    model: 'Modelo',
    filesAnalyzed: 'Archivos Analizados',
    timestamp: 'Marca de Tiempo',
    analysis: 'AnÃ¡lisis',
    generatedBy: 'Este anÃ¡lisis fue generado por',
    verifyBeforeApplying: 'Siempre verifique las sugerencias antes de aplicarlas.',
    reportStatus: 'Estado del Reporte',
    insufficientInfo: 'INFORMACIÃ“N INSUFICIENTE',
    unableToAnalyze: 'No se Puede Analizar',
    insufficientInfoReason: 'Este reporte de error no contiene suficiente informaciÃ³n para el anÃ¡lisis automÃ¡tico.',
    whatWeNeed: 'Lo que Necesitamos',
    errorMessages: 'Mensajes de error o trazas de pila',
    stepsToReproduce: 'Pasos para reproducir',
    expectedVsActual: 'Comportamiento esperado vs real',
    consoleLogs: 'Registros de consola',
    nextSteps: 'PrÃ³ximos Pasos',
    updateIssue: 'Actualice este issue con mÃ¡s detalles',
    submitNewReport: 'EnvÃ­e un nuevo reporte con el widget inner-lens',
    classification: 'ClasificaciÃ³n',
    analysisResult: 'Resultado del AnÃ¡lisis',
    codeVerification: 'VerificaciÃ³n de CÃ³digo',
    noBugFound: 'No se encontrÃ³ error en el cÃ³digo',
    possibleExplanation: 'Posible ExplicaciÃ³n',
    recommendation: 'RecomendaciÃ³n',
    featureRequestNote: 'Esto parece ser una solicitud de funciÃ³n en lugar de un reporte de error.',
    expectedBehavior: 'Comportamiento Esperado',
    workingAsDesigned: 'El comportamiento reportado funciona segÃºn lo diseÃ±ado.',
    unableToConfirm: 'No se Puede Confirmar',
    whatThisMeans: 'Lo que esto significa',
    bugMayExist: 'El error puede existir en cÃ³digo que no analizamos',
    environmentSpecific: 'El problema puede ser especÃ­fico del entorno',
    moreInfoNeeded: 'Se puede necesitar mÃ¡s informaciÃ³n',
    suggestedNextSteps: 'PrÃ³ximos pasos sugeridos',
    provideConsoleLogs: 'Proporcione registros de consola con el error',
    shareStepsToReproduce: 'Comparta los pasos para reproducir',
    includeExactError: 'Incluya el mensaje de error exacto',
    bugFoundInCode: 'Error Encontrado en CÃ³digo',
    yes: 'SÃ­',
    no: 'No',
    confirmedBug: 'Error Confirmado',
    notABug: 'No es un Error',
    featureRequest: 'Solicitud de FunciÃ³n',
    improvementSuggestion: 'Sugerencia de Mejora',
    cannotVerify: 'No se Puede Verificar',
    needsMoreInfo: 'Necesita MÃ¡s Info',
    runtimeError: 'Error de EjecuciÃ³n',
    logicError: 'Error de LÃ³gica',
    performanceIssue: 'Problema de Rendimiento',
    securityIssue: 'Problema de Seguridad',
    uiUxIssue: 'Problema de UI/UX',
    configurationIssue: 'Problema de ConfiguraciÃ³n',
    invalidReport: 'Reporte InvÃ¡lido',
    unknown: 'Desconocido',
  },
  de: {
    analysisTitle: 'inner-lens Analyse',
    severity: 'Schweregrad',
    category: 'Kategorie',
    confidence: 'Konfidenz',
    rootCause: 'Grundursache',
    suggestedFix: 'Vorgeschlagene LÃ¶sung',
    prevention: 'PrÃ¤vention',
    additionalNotes: 'ZusÃ¤tzliche Hinweise',
    affectedFiles: 'Betroffene Dateien',
    codeChanges: 'Code-Ã„nderungen',
    before: 'Vorher',
    after: 'Nachher',
    analysisMetadata: 'Analyse-Metadaten',
    provider: 'Anbieter',
    model: 'Modell',
    filesAnalyzed: 'Analysierte Dateien',
    timestamp: 'Zeitstempel',
    analysis: 'Analyse',
    generatedBy: 'Diese Analyse wurde generiert von',
    verifyBeforeApplying: 'ÃœberprÃ¼fen Sie die VorschlÃ¤ge immer vor der Anwendung.',
    reportStatus: 'Berichtstatus',
    insufficientInfo: 'UNZUREICHENDE INFORMATIONEN',
    unableToAnalyze: 'Analyse nicht mÃ¶glich',
    insufficientInfoReason: 'Dieser Fehlerbericht enthÃ¤lt nicht genÃ¼gend Informationen fÃ¼r eine automatische Analyse.',
    whatWeNeed: 'Was wir benÃ¶tigen',
    errorMessages: 'Fehlermeldungen oder Stack-Traces',
    stepsToReproduce: 'Schritte zur Reproduktion',
    expectedVsActual: 'Erwartetes vs. tatsÃ¤chliches Verhalten',
    consoleLogs: 'Konsolen-Logs',
    nextSteps: 'NÃ¤chste Schritte',
    updateIssue: 'Aktualisieren Sie dieses Issue mit mehr Details',
    submitNewReport: 'Reichen Sie einen neuen Bericht mit dem inner-lens Widget ein',
    classification: 'Klassifizierung',
    analysisResult: 'Analyseergebnis',
    codeVerification: 'Code-Verifizierung',
    noBugFound: 'Kein Fehler im Code gefunden',
    possibleExplanation: 'MÃ¶gliche ErklÃ¤rung',
    recommendation: 'Empfehlung',
    featureRequestNote: 'Dies scheint eine Funktionsanfrage statt eines Fehlerberichts zu sein.',
    expectedBehavior: 'Erwartetes Verhalten',
    workingAsDesigned: 'Das gemeldete Verhalten funktioniert wie vorgesehen.',
    unableToConfirm: 'BestÃ¤tigung nicht mÃ¶glich',
    whatThisMeans: 'Was dies bedeutet',
    bugMayExist: 'Der Fehler kÃ¶nnte in Code existieren, den wir nicht analysiert haben',
    environmentSpecific: 'Das Problem kÃ¶nnte umgebungsspezifisch sein',
    moreInfoNeeded: 'MÃ¶glicherweise werden weitere Informationen benÃ¶tigt',
    suggestedNextSteps: 'Empfohlene nÃ¤chste Schritte',
    provideConsoleLogs: 'Stellen Sie Konsolen-Logs mit dem Fehler bereit',
    shareStepsToReproduce: 'Teilen Sie die Schritte zur Reproduktion',
    includeExactError: 'FÃ¼gen Sie die genaue Fehlermeldung bei',
    bugFoundInCode: 'Fehler im Code gefunden',
    yes: 'Ja',
    no: 'Nein',
    confirmedBug: 'BestÃ¤tigter Fehler',
    notABug: 'Kein Fehler',
    featureRequest: 'Funktionsanfrage',
    improvementSuggestion: 'Verbesserungsvorschlag',
    cannotVerify: 'Nicht verifizierbar',
    needsMoreInfo: 'Mehr Info benÃ¶tigt',
    runtimeError: 'Laufzeitfehler',
    logicError: 'Logikfehler',
    performanceIssue: 'Leistungsproblem',
    securityIssue: 'Sicherheitsproblem',
    uiUxIssue: 'UI/UX-Problem',
    configurationIssue: 'Konfigurationsproblem',
    invalidReport: 'UngÃ¼ltiger Bericht',
    unknown: 'Unbekannt',
  },
  fr: {
    analysisTitle: 'Analyse inner-lens',
    severity: 'SÃ©vÃ©ritÃ©',
    category: 'CatÃ©gorie',
    confidence: 'Confiance',
    rootCause: 'Cause Racine',
    suggestedFix: 'Correction SuggÃ©rÃ©e',
    prevention: 'PrÃ©vention',
    additionalNotes: 'Notes Additionnelles',
    affectedFiles: 'Fichiers AffectÃ©s',
    codeChanges: 'Modifications du Code',
    before: 'Avant',
    after: 'AprÃ¨s',
    analysisMetadata: 'MÃ©tadonnÃ©es de l\'Analyse',
    provider: 'Fournisseur',
    model: 'ModÃ¨le',
    filesAnalyzed: 'Fichiers AnalysÃ©s',
    timestamp: 'Horodatage',
    analysis: 'Analyse',
    generatedBy: 'Cette analyse a Ã©tÃ© gÃ©nÃ©rÃ©e par',
    verifyBeforeApplying: 'VÃ©rifiez toujours les suggestions avant de les appliquer.',
    reportStatus: 'Statut du Rapport',
    insufficientInfo: 'INFORMATIONS INSUFFISANTES',
    unableToAnalyze: 'Impossible d\'Analyser',
    insufficientInfoReason: 'Ce rapport de bug ne contient pas assez d\'informations pour une analyse automatique.',
    whatWeNeed: 'Ce dont nous avons besoin',
    errorMessages: 'Messages d\'erreur ou traces de pile',
    stepsToReproduce: 'Ã‰tapes pour reproduire',
    expectedVsActual: 'Comportement attendu vs rÃ©el',
    consoleLogs: 'Logs de console',
    nextSteps: 'Prochaines Ã‰tapes',
    updateIssue: 'Mettez Ã  jour cette issue avec plus de dÃ©tails',
    submitNewReport: 'Soumettez un nouveau rapport avec le widget inner-lens',
    classification: 'Classification',
    analysisResult: 'RÃ©sultat de l\'Analyse',
    codeVerification: 'VÃ©rification du Code',
    noBugFound: 'Aucun bug trouvÃ© dans le code',
    possibleExplanation: 'Explication Possible',
    recommendation: 'Recommandation',
    featureRequestNote: 'Ceci semble Ãªtre une demande de fonctionnalitÃ© plutÃ´t qu\'un rapport de bug.',
    expectedBehavior: 'Comportement Attendu',
    workingAsDesigned: 'Le comportement signalÃ© fonctionne comme prÃ©vu.',
    unableToConfirm: 'Impossible de Confirmer',
    whatThisMeans: 'Ce que cela signifie',
    bugMayExist: 'Le bug peut exister dans du code que nous n\'avons pas analysÃ©',
    environmentSpecific: 'Le problÃ¨me peut Ãªtre spÃ©cifique Ã  l\'environnement',
    moreInfoNeeded: 'Plus d\'informations peuvent Ãªtre nÃ©cessaires',
    suggestedNextSteps: 'Prochaines Ã©tapes suggÃ©rÃ©es',
    provideConsoleLogs: 'Fournissez les logs de console avec l\'erreur',
    shareStepsToReproduce: 'Partagez les Ã©tapes pour reproduire',
    includeExactError: 'Incluez le message d\'erreur exact',
    bugFoundInCode: 'Bug TrouvÃ© dans le Code',
    yes: 'Oui',
    no: 'Non',
    confirmedBug: 'Bug ConfirmÃ©',
    notABug: 'Pas un Bug',
    featureRequest: 'Demande de FonctionnalitÃ©',
    improvementSuggestion: 'Suggestion d\'AmÃ©lioration',
    cannotVerify: 'Non VÃ©rifiable',
    needsMoreInfo: 'Plus d\'Info Requise',
    runtimeError: 'Erreur d\'ExÃ©cution',
    logicError: 'Erreur de Logique',
    performanceIssue: 'ProblÃ¨me de Performance',
    securityIssue: 'ProblÃ¨me de SÃ©curitÃ©',
    uiUxIssue: 'ProblÃ¨me UI/UX',
    configurationIssue: 'ProblÃ¨me de Configuration',
    invalidReport: 'Rapport Invalide',
    unknown: 'Inconnu',
  },
  pt: {
    analysisTitle: 'AnÃ¡lise inner-lens',
    severity: 'Severidade',
    category: 'Categoria',
    confidence: 'ConfianÃ§a',
    rootCause: 'Causa Raiz',
    suggestedFix: 'CorreÃ§Ã£o Sugerida',
    prevention: 'PrevenÃ§Ã£o',
    additionalNotes: 'Notas Adicionais',
    affectedFiles: 'Arquivos Afetados',
    codeChanges: 'AlteraÃ§Ãµes de CÃ³digo',
    before: 'Antes',
    after: 'Depois',
    analysisMetadata: 'Metadados da AnÃ¡lise',
    provider: 'Provedor',
    model: 'Modelo',
    filesAnalyzed: 'Arquivos Analisados',
    timestamp: 'Timestamp',
    analysis: 'AnÃ¡lise',
    generatedBy: 'Esta anÃ¡lise foi gerada por',
    verifyBeforeApplying: 'Sempre verifique as sugestÃµes antes de aplicar.',
    reportStatus: 'Status do RelatÃ³rio',
    insufficientInfo: 'INFORMAÃ‡Ã•ES INSUFICIENTES',
    unableToAnalyze: 'NÃ£o Ã© PossÃ­vel Analisar',
    insufficientInfoReason: 'Este relatÃ³rio de bug nÃ£o contÃ©m informaÃ§Ãµes suficientes para anÃ¡lise automÃ¡tica.',
    whatWeNeed: 'O que Precisamos',
    errorMessages: 'Mensagens de erro ou stack traces',
    stepsToReproduce: 'Passos para reproduzir',
    expectedVsActual: 'Comportamento esperado vs real',
    consoleLogs: 'Logs do console',
    nextSteps: 'PrÃ³ximos Passos',
    updateIssue: 'Atualize esta issue com mais detalhes',
    submitNewReport: 'Envie um novo relatÃ³rio com o widget inner-lens',
    classification: 'ClassificaÃ§Ã£o',
    analysisResult: 'Resultado da AnÃ¡lise',
    codeVerification: 'VerificaÃ§Ã£o de CÃ³digo',
    noBugFound: 'Nenhum bug encontrado no cÃ³digo',
    possibleExplanation: 'PossÃ­vel ExplicaÃ§Ã£o',
    recommendation: 'RecomendaÃ§Ã£o',
    featureRequestNote: 'Isto parece ser uma solicitaÃ§Ã£o de recurso em vez de um relatÃ³rio de bug.',
    expectedBehavior: 'Comportamento Esperado',
    workingAsDesigned: 'O comportamento relatado estÃ¡ funcionando conforme projetado.',
    unableToConfirm: 'NÃ£o Ã© PossÃ­vel Confirmar',
    whatThisMeans: 'O que isso significa',
    bugMayExist: 'O bug pode existir em cÃ³digo que nÃ£o analisamos',
    environmentSpecific: 'O problema pode ser especÃ­fico do ambiente',
    moreInfoNeeded: 'Mais informaÃ§Ãµes podem ser necessÃ¡rias',
    suggestedNextSteps: 'PrÃ³ximos passos sugeridos',
    provideConsoleLogs: 'ForneÃ§a logs do console com o erro',
    shareStepsToReproduce: 'Compartilhe os passos para reproduzir',
    includeExactError: 'Inclua a mensagem de erro exata',
    bugFoundInCode: 'Bug Encontrado no CÃ³digo',
    yes: 'Sim',
    no: 'NÃ£o',
    confirmedBug: 'Bug Confirmado',
    notABug: 'NÃ£o Ã© um Bug',
    featureRequest: 'SolicitaÃ§Ã£o de Recurso',
    improvementSuggestion: 'SugestÃ£o de Melhoria',
    cannotVerify: 'NÃ£o VerificÃ¡vel',
    needsMoreInfo: 'Precisa de Mais Info',
    runtimeError: 'Erro de ExecuÃ§Ã£o',
    logicError: 'Erro de LÃ³gica',
    performanceIssue: 'Problema de Performance',
    securityIssue: 'Problema de SeguranÃ§a',
    uiUxIssue: 'Problema de UI/UX',
    configurationIssue: 'Problema de ConfiguraÃ§Ã£o',
    invalidReport: 'RelatÃ³rio InvÃ¡lido',
    unknown: 'Desconhecido',
  },
};

/**
 * Get i18n strings for the specified language
 */
function getI18n(language: OutputLanguage): I18nStrings {
  return I18N[language] || I18N.en;
}

interface AnalysisConfig {
  provider: AIProvider;
  model: string;
  issueNumber: number;
  owner: string;
  repo: string;
  maxFiles: number;
  maxTokens: number;
  retryAttempts: number;
  retryDelay: number;
  // Self-consistency settings (P3-2)
  selfConsistency: boolean;
  consistencySamples: number;
  consistencyThreshold: number;
  // AST-like chunking (P3-1)
  useChunking: boolean;
  // Output language for analysis comments
  language: OutputLanguage;
}

// Structured output schema for analysis
// Schema for a single root cause analysis
const RootCauseAnalysisSchema = z.object({
  severity: z.enum(['critical', 'high', 'medium', 'low', 'none']),
  category: z.enum(['runtime_error', 'logic_error', 'performance', 'security', 'ui_ux', 'configuration', 'invalid_report', 'unknown']),
  codeVerification: z.object({
    bugExistsInCode: z.boolean().describe('After analyzing the code, does the described bug actually exist?'),
    evidence: z.string().describe('What evidence from the code supports or refutes the bug claim?'),
    alternativeExplanation: z.string().optional().describe('If not a bug, what might explain the reported behavior?'),
  }).describe('Result of verifying the bug claim against actual code'),
  rootCause: z.object({
    summary: z.string().describe('One-line summary of the root cause'),
    explanation: z.string().describe('Detailed explanation of why the bug occurred'),
    affectedFiles: z.array(z.string()).describe('List of files likely causing the issue'),
  }),
  suggestedFix: z.object({
    steps: z.array(z.string()).describe('Step-by-step instructions to fix the bug'),
    codeChanges: z.array(z.object({
      file: z.string(),
      description: z.string(),
      before: z.string().optional(),
      after: z.string(),
    })).describe('Specific code changes to implement'),
  }),
  prevention: z.array(z.string()).describe('How to prevent similar issues in the future'),
  confidence: z.number().min(0).max(100).describe('Confidence level of this analysis (0-100)'),
  additionalContext: z.string().optional().describe('Any additional context or caveats'),
});

const AnalysisResultSchema = z.object({
  // Validity check - MUST be evaluated first
  isValidReport: z.boolean().describe('Whether this is a valid, actionable bug report with sufficient information'),
  invalidReason: z.string().optional().describe('If isValidReport is false, explain why (e.g., "No error logs or reproduction steps provided", "Description too vague to analyze")'),

  // Report classification (2025 enhancement)
  reportType: z.enum([
    'bug',              // Actual bug - code is broken
    'not_a_bug',        // Expected behavior - user misunderstanding
    'feature_request',  // Request for new functionality
    'improvement',      // Enhancement to existing feature
    'cannot_verify',    // Cannot confirm bug from code analysis
    'needs_info',       // Insufficient information to analyze
  ]).describe('Classification of what this report actually is'),

  // Multiple root causes support - each will be posted as a separate comment
  analyses: z.array(RootCauseAnalysisSchema)
    .min(1)
    .max(3)
    .describe('Array of potential root causes, ordered by likelihood. Each will be posted as a separate comment. Usually 1, but can be 2-3 if multiple distinct issues are found.'),
});

type AnalysisResult = z.infer<typeof AnalysisResultSchema>;
type RootCauseAnalysis = z.infer<typeof RootCauseAnalysisSchema>;

// ============================================
// Configuration
// ============================================

// Validate and get output language
function getOutputLanguage(): OutputLanguage {
  const lang = process.env['OUTPUT_LANGUAGE']?.toLowerCase() || 'en';
  const validLanguages: OutputLanguage[] = ['en', 'ko', 'ja', 'zh', 'es', 'de', 'fr', 'pt'];
  return validLanguages.includes(lang as OutputLanguage) ? (lang as OutputLanguage) : 'en';
}

const config: AnalysisConfig = {
  provider: (process.env['AI_PROVIDER'] as AIProvider) || 'anthropic',
  model: process.env['AI_MODEL'] || '',
  issueNumber: parseInt(process.env['ISSUE_NUMBER'] || '0', 10),
  owner: process.env['REPO_OWNER'] || '',
  repo: process.env['REPO_NAME'] || '',
  maxFiles: parseInt(process.env['MAX_FILES'] || '25', 10),
  maxTokens: parseInt(process.env['MAX_TOKENS'] || '4000', 10),
  retryAttempts: 3,
  retryDelay: 2000,
  // Self-consistency: run multiple analyses and check agreement (P3-2)
  selfConsistency: process.env['SELF_CONSISTENCY'] === 'true',
  consistencySamples: parseInt(process.env['CONSISTENCY_SAMPLES'] || '3', 10),
  consistencyThreshold: parseFloat(process.env['CONSISTENCY_THRESHOLD'] || '0.67'),
  // AST-like chunking: use function/class level chunking (P3-1)
  useChunking: process.env['USE_CHUNKING'] !== 'false', // Default enabled
  // Output language: en (default), ko, ja, zh, es, de, fr, pt
  language: getOutputLanguage(),
};

// ============================================
// Model Selection
// ============================================

// Default models for each provider (2026 latest)
const DEFAULT_MODELS: Record<AIProvider, string> = {
  anthropic: 'claude-sonnet-4-5-20250929',
  openai: 'gpt-4.1',
  google: 'gemini-2.0-flash',
};

function getModel() {
  const modelName = config.model || DEFAULT_MODELS[config.provider];

  switch (config.provider) {
    case 'openai':
      console.log(`ğŸ“¦ Using OpenAI ${modelName}`);
      return openai(modelName);
    case 'google':
      console.log(`ğŸ“¦ Using Google ${modelName}`);
      return google(modelName);
    case 'anthropic':
    default:
      console.log(`ğŸ“¦ Using Anthropic ${modelName}`);
      return anthropic(modelName);
  }
}

// ============================================
// Security: Enhanced Data Masking
// ============================================
// Note: maskSensitiveData is imported from src/utils/masking.ts
// to ensure consistent masking patterns (20 patterns) across the codebase

// ============================================
// Import Graph Tracking (P1-1)
// ============================================

interface ImportInfo {
  source: string;      // The import path as written
  resolved: string | null;  // Resolved file path (null if not found)
  isRelative: boolean; // Is it a relative import?
  type: 'import' | 'require' | 'dynamic'; // Type of import
}

/**
 * Parse import statements from TypeScript/JavaScript file content
 * Supports:
 * - ES6 imports: import { x } from 'module'
 * - ES6 default imports: import x from 'module'
 * - ES6 namespace imports: import * as x from 'module'
 * - CommonJS: require('module')
 * - Dynamic imports: import('module')
 * - Re-exports: export { x } from 'module'
 */
function parseImports(content: string): ImportInfo[] {
  const imports: ImportInfo[] = [];
  const seenSources = new Set<string>();

  // Pattern 1: ES6 static imports - import ... from 'module'
  const es6ImportPattern = /import\s+(?:(?:\{[^}]*\}|\*\s+as\s+\w+|\w+(?:\s*,\s*\{[^}]*\})?)\s+from\s+)?['"]([^'"]+)['"]/g;
  let match;
  while ((match = es6ImportPattern.exec(content)) !== null) {
    const source = match[1];
    if (source && !seenSources.has(source)) {
      seenSources.add(source);
      imports.push({
        source,
        resolved: null,
        isRelative: source.startsWith('.') || source.startsWith('/'),
        type: 'import',
      });
    }
  }

  // Pattern 2: CommonJS require - require('module')
  const requirePattern = /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
  while ((match = requirePattern.exec(content)) !== null) {
    const source = match[1];
    if (source && !seenSources.has(source)) {
      seenSources.add(source);
      imports.push({
        source,
        resolved: null,
        isRelative: source.startsWith('.') || source.startsWith('/'),
        type: 'require',
      });
    }
  }

  // Pattern 3: Dynamic imports - import('module')
  const dynamicImportPattern = /import\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
  while ((match = dynamicImportPattern.exec(content)) !== null) {
    const source = match[1];
    if (source && !seenSources.has(source)) {
      seenSources.add(source);
      imports.push({
        source,
        resolved: null,
        isRelative: source.startsWith('.') || source.startsWith('/'),
        type: 'dynamic',
      });
    }
  }

  // Pattern 4: Re-exports - export { x } from 'module'
  const reExportPattern = /export\s+(?:\{[^}]*\}|\*)\s+from\s+['"]([^'"]+)['"]/g;
  while ((match = reExportPattern.exec(content)) !== null) {
    const source = match[1];
    if (source && !seenSources.has(source)) {
      seenSources.add(source);
      imports.push({
        source,
        resolved: null,
        isRelative: source.startsWith('.') || source.startsWith('/'),
        type: 'import',
      });
    }
  }

  return imports;
}

/**
 * Resolve import path to actual file path
 * Handles common resolution patterns:
 * - Relative paths: ./foo, ../bar
 * - Extension inference: .ts, .tsx, .js, .jsx
 * - Index files: ./folder -> ./folder/index.ts
 * - Path aliases are NOT resolved (would need tsconfig)
 */
function resolveImportPath(
  importSource: string,
  fromFile: string,
  baseDir: string
): string | null {
  // Skip non-relative imports (npm packages, path aliases)
  if (!importSource.startsWith('.') && !importSource.startsWith('/')) {
    return null;
  }

  const fromDir = path.dirname(fromFile);
  const extensions = ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs'];

  // Calculate the base path
  let basePath: string;
  if (importSource.startsWith('/')) {
    basePath = path.join(baseDir, importSource);
  } else {
    basePath = path.join(fromDir, importSource);
  }

  // Try direct path with extensions
  for (const ext of extensions) {
    const fullPath = basePath + ext;
    if (fs.existsSync(fullPath)) {
      return fullPath;
    }
  }

  // Try index file in directory
  for (const ext of extensions) {
    const indexPath = path.join(basePath, `index${ext}`);
    if (fs.existsSync(indexPath)) {
      return indexPath;
    }
  }

  // Try exact path (already has extension)
  if (fs.existsSync(basePath)) {
    return basePath;
  }

  return null;
}

/**
 * Build import graph from relevant files
 * Returns a map of file -> imported files
 */
function buildImportGraph(
  files: FileInfo[],
  baseDir: string,
  maxFilesToParse = 20
): Map<string, string[]> {
  const graph = new Map<string, string[]>();
  const filesToParse = files.slice(0, maxFilesToParse);

  for (const file of filesToParse) {
    try {
      const content = fs.readFileSync(file.path, 'utf-8');
      const imports = parseImports(content);

      const resolvedImports: string[] = [];
      for (const imp of imports) {
        if (imp.isRelative) {
          const resolved = resolveImportPath(imp.source, file.path, baseDir);
          if (resolved) {
            resolvedImports.push(resolved);
          }
        }
      }

      if (resolvedImports.length > 0) {
        graph.set(file.path, resolvedImports);
      }
    } catch {
      // Skip files we can't read
    }
  }

  return graph;
}

/**
 * Expand file list with imported dependencies
 * Adds files that are imported by the top relevant files
 */
function expandFilesWithImports(
  files: FileInfo[],
  importGraph: Map<string, string[]>,
  maxExpansion = 10
): FileInfo[] {
  const existingPaths = new Set(files.map(f => f.path));
  const newFiles: FileInfo[] = [];

  // Get all imported files that aren't already in our list
  for (const [sourceFile, imports] of Array.from(importGraph.entries())) {
    // Get the source file's score to derive imported file scores
    const sourceFileInfo = files.find(f => f.path === sourceFile);
    const baseScore = sourceFileInfo?.relevanceScore || 0;

    for (const importedPath of imports) {
      if (!existingPaths.has(importedPath) && newFiles.length < maxExpansion) {
        existingPaths.add(importedPath);

        try {
          const stats = fs.statSync(importedPath);
          newFiles.push({
            path: importedPath,
            size: stats.size,
            // Imported files get 60% of the importing file's score
            relevanceScore: Math.floor(baseScore * 0.6),
            pathScore: 0,
            contentScore: 0,
            matchedKeywords: [`imported-by:${path.basename(sourceFile)}`],
          });
        } catch {
          // Skip files we can't stat
        }
      }
    }
  }

  // Sort new files by derived score
  newFiles.sort((a, b) => b.relevanceScore - a.relevanceScore);

  return [...files, ...newFiles];
}

// ============================================
// LLM Re-ranking (P1-2)
// ============================================

/**
 * Extract a brief summary of a file for LLM re-ranking
 */
function extractFileSummary(filePath: string, maxChars = 800): string {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Extract imports and exports first (useful context)
    const importLines: string[] = [];
    const exportLines: string[] = [];
    const otherLines: string[] = [];

    const lines = content.split('\n');
    for (const line of lines.slice(0, 50)) {
      const trimmed = line.trim();
      if (trimmed.startsWith('import ') || trimmed.startsWith('const ') && trimmed.includes('require(')) {
        importLines.push(trimmed);
      } else if (trimmed.startsWith('export ')) {
        exportLines.push(trimmed);
      } else if (trimmed.startsWith('function ') || trimmed.startsWith('class ') ||
                 trimmed.startsWith('const ') || trimmed.startsWith('interface ') ||
                 trimmed.startsWith('type ')) {
        otherLines.push(trimmed);
      }
    }

    // Build summary prioritizing structure
    const parts = [
      ...exportLines.slice(0, 5),
      ...otherLines.slice(0, 10),
      ...importLines.slice(0, 3),
    ];

    let summary = parts.join('\n').slice(0, maxChars);
    if (summary.length >= maxChars) {
      summary = summary.slice(0, maxChars - 3) + '...';
    }

    return summary || content.slice(0, maxChars);
  } catch {
    return '';
  }
}

interface RerankCandidate {
  path: string;
  summary: string;
  originalScore: number;
  originalRank: number;
}

interface RerankResult {
  path: string;
  newScore: number;
  reason: string;
}

/**
 * Use LLM to re-rank file candidates based on relevance to the bug report
 * Uses a fast/cheap model to minimize cost and latency
 */
async function rerankFilesWithLLM(
  files: FileInfo[],
  issueTitle: string,
  issueBody: string,
  maxCandidates = 15
): Promise<FileInfo[]> {
  // Only rerank if we have enough candidates
  if (files.length < 5) {
    return files;
  }

  const candidates: RerankCandidate[] = files
    .slice(0, maxCandidates)
    .map((f, i) => ({
      path: f.path,
      summary: extractFileSummary(f.path),
      originalScore: f.relevanceScore,
      originalRank: i + 1,
    }))
    .filter(c => c.summary.length > 50); // Skip empty summaries

  if (candidates.length < 3) {
    return files;
  }

  // Build the re-ranking prompt
  const rerankPrompt = `You are a code search expert. Given a bug report and a list of candidate files, rank them by relevance.

## Bug Report
**Title:** ${issueTitle}
**Description:** ${issueBody.slice(0, 1500)}

## Candidate Files (ranked by initial search score)
${candidates.map((c, i) => `
### [${i + 1}] ${c.path}
\`\`\`
${c.summary}
\`\`\`
`).join('\n')}

## Task
Rerank these files from MOST relevant to LEAST relevant for debugging this bug.
Output a JSON array of objects with: {"path": "file/path", "score": 0-100, "reason": "brief reason"}
Order by score descending. Only include files that are potentially relevant (score > 30).

IMPORTANT: Output ONLY the JSON array, no markdown code blocks or explanation.`;

  try {
    // Use the cheapest/fastest model for re-ranking (2025 pricing)
    // OpenAI gpt-4.1-nano: $0.10/$0.40 per 1M tokens
    // Google gemini-2.5-flash-lite: $0.10/$0.40 per 1M tokens
    // Anthropic claude-3-haiku: $0.25/$1.25 per 1M tokens (cheapest available)
    let rerankModel;
    switch (config.provider) {
      case 'openai':
        rerankModel = openai('gpt-4.1-nano');
        break;
      case 'google':
        rerankModel = google('gemini-2.5-flash-lite');
        break;
      case 'anthropic':
      default:
        rerankModel = anthropic('claude-3-haiku-20240307');
        break;
    }

    const { text } = await generateText({
      model: rerankModel,
      prompt: rerankPrompt,
      maxTokens: 1000,
      temperature: 0.1, // Low temperature for consistent ranking
    });

    // Parse the response
    let rerankResults: RerankResult[];
    try {
      // Clean up the response (remove markdown code blocks if present)
      let cleanText = text.trim();
      if (cleanText.startsWith('```')) {
        cleanText = cleanText.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
      }
      rerankResults = JSON.parse(cleanText);
    } catch (parseError) {
      console.log('   âš ï¸ Could not parse LLM re-ranking response, using original order');
      return files;
    }

    if (!Array.isArray(rerankResults) || rerankResults.length === 0) {
      return files;
    }

    // Create a map of path -> new score
    const scoreMap = new Map<string, number>();
    for (const result of rerankResults) {
      if (result.path && typeof result.newScore === 'number') {
        // Normalize LLM score (0-100) to our scale
        scoreMap.set(result.path, result.newScore * 2); // Scale to ~0-200 range
      }
    }

    // Update file scores based on LLM ranking
    const rerankedFiles = files.map(f => {
      const llmScore = scoreMap.get(f.path);
      if (llmScore !== undefined) {
        return {
          ...f,
          // Blend original score with LLM score (70% LLM, 30% original for top candidates)
          relevanceScore: Math.floor(llmScore * 0.7 + f.relevanceScore * 0.3),
          matchedKeywords: [...f.matchedKeywords, 'llm-reranked'],
        };
      }
      return f;
    });

    // Re-sort by updated scores
    rerankedFiles.sort((a, b) => b.relevanceScore - a.relevanceScore);

    return rerankedFiles;
  } catch (error) {
    console.log(`   âš ï¸ LLM re-ranking failed: ${error instanceof Error ? error.message : 'unknown error'}`);
    return files;
  }
}

// ============================================
// Architecture-Aware File Classification (2025 Enhancement)
// ============================================

/**
 * File role classification for architecture-aware analysis
 * Helps prevent misattributing bugs to wrong file types
 * (e.g., suggesting analytics files for validation bugs)
 */
type FileRole =
  | 'component'    // React/Vue components, pages
  | 'hook'         // Custom hooks (useXxx)
  | 'api'          // API routes, endpoints
  | 'schema'       // Zod schemas, type definitions, validation
  | 'util'         // Utility functions, helpers
  | 'config'       // Configuration files
  | 'test'         // Test files
  | 'analytics'    // Analytics, tracking, telemetry (NOT business logic)
  | 'style'        // CSS, styling files
  | 'unknown';     // Cannot determine

/**
 * Bug category to expected file roles mapping
 * Used for confidence calibration when file role doesn't match
 */
const BUG_CATEGORY_EXPECTED_ROLES: Record<string, FileRole[]> = {
  // Validation bugs should be in forms, APIs, or schemas - NOT analytics
  logic_error: ['component', 'hook', 'api', 'schema', 'util'],
  runtime_error: ['component', 'hook', 'api', 'util'],
  // UI bugs should be in components or styles
  ui_ux: ['component', 'style', 'hook'],
  // Performance issues can be anywhere except analytics/test
  performance: ['component', 'hook', 'api', 'util', 'config'],
  // Security issues typically in auth, API, or config
  security: ['api', 'util', 'config', 'schema'],
  // Configuration issues
  configuration: ['config', 'api', 'util'],
  // Unknown can be anywhere
  unknown: ['component', 'hook', 'api', 'schema', 'util', 'config'],
};

/**
 * File path patterns for role classification
 * Order matters - first match wins
 */
const FILE_ROLE_PATTERNS: Array<{ role: FileRole; patterns: RegExp[] }> = [
  // Analytics/Tracking - IMPORTANT: These should NOT contain business logic
  {
    role: 'analytics',
    patterns: [
      /use[A-Z]?[Aa]nalytics/,           // useAnalytics, useGoogleAnalytics
      /analytics/i,                       // any analytics folder/file
      /tracking/i,                        // tracking utilities
      /telemetry/i,                       // telemetry
      /ga4?\.ts$/i,                       // GA, GA4 specific
      /gtm\.ts$/i,                        // Google Tag Manager
      /mixpanel/i,                        // Mixpanel
      /amplitude/i,                       // Amplitude
      /segment/i,                         // Segment
      /posthog/i,                         // PostHog
    ],
  },
  // Test files
  {
    role: 'test',
    patterns: [
      /\.test\.[jt]sx?$/,
      /\.spec\.[jt]sx?$/,
      /__tests__\//,
      /\/tests?\//,
    ],
  },
  // API routes
  {
    role: 'api',
    patterns: [
      /\/api\//,
      /\/routes?\//,
      /route\.[jt]s$/,
      /controller\.[jt]s$/,
      /server\.[jt]s$/,
    ],
  },
  // Schema/Validation
  {
    role: 'schema',
    patterns: [
      /schema/i,
      /validation/i,
      /validator/i,
      /\/types\//,
      /\.types\.[jt]s$/,
      /\.schema\.[jt]s$/,
      /\.d\.ts$/,
    ],
  },
  // Hooks
  {
    role: 'hook',
    patterns: [
      /\/hooks?\//,
      /use[A-Z][a-zA-Z]+\.[jt]sx?$/,
    ],
  },
  // Components
  {
    role: 'component',
    patterns: [
      /\/components?\//,
      /\/pages?\//,
      /\/app\/.*\/page\.[jt]sx?$/,        // Next.js app router pages
      /\/app\/.*\/layout\.[jt]sx?$/,      // Next.js layouts
      /\.[jt]sx$/,                         // Any JSX/TSX file (last resort for components)
    ],
  },
  // Config
  {
    role: 'config',
    patterns: [
      /config/i,
      /\.config\.[jt]s$/,
      /\.env/,
      /settings/i,
    ],
  },
  // Styles
  {
    role: 'style',
    patterns: [
      /\.css$/,
      /\.scss$/,
      /\.sass$/,
      /\.less$/,
      /styles?\//i,
    ],
  },
  // Utils (broad catch)
  {
    role: 'util',
    patterns: [
      /\/utils?\//,
      /\/lib\//,
      /\/helpers?\//,
      /\/common\//,
    ],
  },
];

/**
 * Classify a file's role based on its path
 */
function classifyFileRole(filePath: string): FileRole {
  const normalizedPath = filePath.toLowerCase().replace(/\\/g, '/');

  for (const { role, patterns } of FILE_ROLE_PATTERNS) {
    for (const pattern of patterns) {
      if (pattern.test(normalizedPath) || pattern.test(filePath)) {
        return role;
      }
    }
  }

  return 'unknown';
}

/**
 * Check if a file role is appropriate for a given bug category
 */
function isRoleAppropriateForCategory(role: FileRole, category: string): boolean {
  // Analytics files should NEVER be suggested for business logic bugs
  if (role === 'analytics') {
    return false; // Analytics files don't contain business logic
  }

  // Test files are not bug sources (unless the test itself is buggy)
  if (role === 'test') {
    return false;
  }

  const expectedRoles = BUG_CATEGORY_EXPECTED_ROLES[category];
  if (!expectedRoles) {
    return true; // Unknown category, allow any role
  }

  return expectedRoles.includes(role);
}

// ============================================
// Confidence Calibration (2025 Enhancement)
// ============================================

interface ConfidenceCalibrationResult {
  originalConfidence: number;
  calibratedConfidence: number;
  penalties: string[];
  wasCalibrated: boolean;
}

/**
 * Calibrate confidence score based on evidence quality and consistency
 * Addresses the QA feedback about over-confident results
 *
 * Key calibration factors:
 * 1. No specific file identified â†’ max 40%
 * 2. No line number match â†’ -20%
 * 3. File role mismatch (e.g., analytics for validation bug) â†’ -25%
 * 4. Uncertainty markers in explanation â†’ cap at 60%
 * 5. No code verification evidence â†’ -15%
 */
function calibrateConfidence(
  analysis: RootCauseAnalysis,
  errorLocations: ErrorLocation[],
): ConfidenceCalibrationResult {
  const originalConfidence = analysis.confidence;
  let calibrated = originalConfidence;
  const penalties: string[] = [];

  // 1. No affected files identified
  if (!analysis.rootCause.affectedFiles || analysis.rootCause.affectedFiles.length === 0) {
    calibrated = Math.min(calibrated, 40);
    penalties.push('No specific file identified (capped at 40%)');
  }

  // 2. Check for line number precision
  const hasLineMatch = errorLocations.some(loc =>
    loc.line && analysis.rootCause.affectedFiles.some(f =>
      f.toLowerCase().includes(loc.file.toLowerCase())
    )
  );
  if (!hasLineMatch && calibrated > 70) {
    calibrated -= 20;
    penalties.push('No line number correlation with error trace (-20%)');
  }

  // 3. File role appropriateness check
  if (analysis.rootCause.affectedFiles.length > 0) {
    const primaryFile = analysis.rootCause.affectedFiles[0];
    if (primaryFile) {
      const fileRole = classifyFileRole(primaryFile);
      if (!isRoleAppropriateForCategory(fileRole, analysis.category)) {
        calibrated -= 25;
        penalties.push(`File role mismatch: ${fileRole} file suggested for ${analysis.category} bug (-25%)`);

        // Add specific warning for analytics files
        if (fileRole === 'analytics') {
          penalties.push('âš ï¸ Analytics/tracking files should not contain business logic');
        }
      }
    }
  }

  // 4. Uncertainty markers in explanation
  const uncertaintyMarkers = [
    'uncertain', 'not sure', 'unclear', 'possibly', 'might be',
    'could be', 'may be', 'perhaps', 'speculative',
    'ë¶ˆí™•ì‹¤', 'ì¶”ê°€ ì¡°ì‚¬', 'í™•ì¸ í•„ìš”', 'ê°€ëŠ¥ì„±',
    'å¯èƒ½', 'ä¸ç¡®å®š', 'ä¹Ÿè®¸',
  ];
  const explanationLower = (
    analysis.rootCause.explanation +
    (analysis.additionalContext || '')
  ).toLowerCase();

  if (uncertaintyMarkers.some(marker => explanationLower.includes(marker))) {
    calibrated = Math.min(calibrated, 60);
    penalties.push('Uncertainty markers detected in explanation (capped at 60%)');
  }

  // 5. No code verification evidence
  if (!analysis.codeVerification.bugExistsInCode &&
      (!analysis.codeVerification.evidence || analysis.codeVerification.evidence.length < 50)) {
    calibrated -= 15;
    penalties.push('Insufficient code verification evidence (-15%)');
  }

  // Ensure confidence stays in valid range
  calibrated = Math.max(0, Math.min(100, Math.round(calibrated)));

  return {
    originalConfidence,
    calibratedConfidence: calibrated,
    penalties,
    wasCalibrated: calibrated !== originalConfidence,
  };
}

/**
 * Apply confidence calibration to all analyses in a result
 */
function calibrateAllAnalyses(
  result: AnalysisResult,
  errorLocations: ErrorLocation[],
): { result: AnalysisResult; calibrationReports: ConfidenceCalibrationResult[] } {
  const calibrationReports: ConfidenceCalibrationResult[] = [];

  const calibratedAnalyses = result.analyses.map(analysis => {
    const calibration = calibrateConfidence(analysis, errorLocations);
    calibrationReports.push(calibration);

    // Return analysis with calibrated confidence
    return {
      ...analysis,
      confidence: calibration.calibratedConfidence,
      // Add calibration note to additionalContext if calibrated
      additionalContext: calibration.wasCalibrated
        ? `${analysis.additionalContext || ''}\n\nğŸ“Š **Confidence Calibration:** Original ${calibration.originalConfidence}% â†’ Adjusted ${calibration.calibratedConfidence}%${calibration.penalties.length > 0 ? `\n- ${calibration.penalties.join('\n- ')}` : ''}`
        : analysis.additionalContext,
    };
  });

  return {
    result: {
      ...result,
      analyses: calibratedAnalyses,
    },
    calibrationReports,
  };
}

// ============================================
// Smart File Discovery
// ============================================

interface FileInfo {
  path: string;
  size: number;
  relevanceScore: number;
  pathScore: number;      // Score from path matching
  contentScore: number;   // Score from content matching
  matchedKeywords: string[]; // Which keywords matched
}

interface SearchContext {
  keywords: string[];
  errorLocations: ErrorLocation[];
  errorMessages: string[];
  functionNames: string[];
}

/**
 * Search file content for keywords and calculate relevance
 * Uses sampling for large files to maintain performance
 */
function searchFileContent(
  filePath: string,
  searchContext: SearchContext,
  maxReadSize = 50000 // Read max 50KB per file for performance
): { score: number; matchedKeywords: string[] } {
  let score = 0;
  const matchedKeywords: string[] = [];

  try {
    const stats = fs.statSync(filePath);
    const content = fs.readFileSync(
      filePath,
      { encoding: 'utf-8', flag: 'r' }
    ).slice(0, maxReadSize).toLowerCase();

    // 1. Check for error location file matches (highest priority)
    for (const loc of searchContext.errorLocations) {
      const fileName = loc.file.toLowerCase();
      if (path.basename(filePath).toLowerCase() === fileName) {
        score += 50; // Direct file match from stack trace
        matchedKeywords.push(`stacktrace:${loc.file}`);

        // Bonus if we can find the specific line context
        if (loc.line && loc.functionName) {
          if (content.includes(loc.functionName.toLowerCase())) {
            score += 20;
            matchedKeywords.push(`function:${loc.functionName}`);
          }
        }
      }
    }

    // 2. Check for function names from error context
    for (const funcName of searchContext.functionNames) {
      const funcLower = funcName.toLowerCase();
      // Match function definitions or calls
      const patterns = [
        `function ${funcLower}`,
        `const ${funcLower}`,
        `${funcLower}(`,
        `${funcLower} =`,
        `.${funcLower}(`,
      ];
      for (const pattern of patterns) {
        if (content.includes(pattern)) {
          score += 25;
          matchedKeywords.push(`function:${funcName}`);
          break;
        }
      }
    }

    // 3. Check for error message fragments
    for (const errMsg of searchContext.errorMessages) {
      const msgWords = errMsg.toLowerCase().split(/\s+/).filter(w => w.length > 3);
      let matchCount = 0;
      for (const word of msgWords) {
        if (content.includes(word)) matchCount++;
      }
      if (matchCount >= 2 || (msgWords.length === 1 && matchCount === 1)) {
        score += 15;
        matchedKeywords.push(`error:${errMsg.slice(0, 30)}`);
      }
    }

    // 4. General keyword matching in content
    for (const keyword of searchContext.keywords) {
      const keyLower = keyword.toLowerCase();
      if (keyLower.length < 3) continue; // Skip short keywords

      // Exact match (with word boundaries approximation)
      const exactMatches = content.split(keyLower).length - 1;
      if (exactMatches > 0) {
        score += Math.min(exactMatches * 5, 20); // Cap at 20 per keyword
        matchedKeywords.push(keyword);
      }
    }

  } catch {
    // File read error - skip content scoring
  }

  return { score, matchedKeywords: [...new Set(matchedKeywords)] };
}

/**
 * Calculate path-based relevance score
 */
function calculatePathRelevance(filePath: string, keywords: string[]): number {
  let score = 0;
  const lowerPath = filePath.toLowerCase();

  // Keyword matching in path
  for (const keyword of keywords) {
    if (keyword.length < 2) continue;
    if (lowerPath.includes(keyword.toLowerCase())) {
      score += 15;
    }
  }

  // File type priorities
  if (lowerPath.includes('error') || lowerPath.includes('exception')) score += 10;
  if (lowerPath.includes('handler') || lowerPath.includes('controller')) score += 8;
  if (lowerPath.includes('api/') || lowerPath.includes('route')) score += 7;
  if (lowerPath.includes('page.tsx') || lowerPath.includes('page.ts')) score += 6;
  if (lowerPath.includes('component')) score += 5;
  if (lowerPath.includes('hook') || lowerPath.includes('use')) score += 4;
  if (lowerPath.includes('store') || lowerPath.includes('state')) score += 4;
  if (lowerPath.includes('util') || lowerPath.includes('lib') || lowerPath.includes('helper')) score += 3;
  if (lowerPath.includes('service') || lowerPath.includes('client')) score += 3;
  if (lowerPath.includes('config') || lowerPath.includes('setting')) score += 2;

  // Penalize test files for bug analysis
  if (lowerPath.includes('.test.') || lowerPath.includes('.spec.') || lowerPath.includes('__test__')) {
    score -= 10;
  }

  return score;
}

function findRelevantFiles(
  dir: string,
  keywords: string[],
  errorLocations: ErrorLocation[] = [],
  errorMessages: string[] = [],
  extensions = ['.ts', '.tsx', '.js', '.jsx', '.py', '.go', '.rs', '.java', '.kt'],
  ignoreDirs = ['node_modules', '.git', 'dist', 'build', '.next', 'coverage', '__pycache__', 'vendor']
): FileInfo[] {
  const files: FileInfo[] = [];

  // Extract function names from error locations
  const functionNames = errorLocations
    .filter(loc => loc.functionName)
    .map(loc => loc.functionName!);

  const searchContext: SearchContext = {
    keywords,
    errorLocations,
    errorMessages,
    functionNames,
  };

  function walk(currentDir: string, depth = 0): void {
    if (depth > 6) return;

    try {
      const items = fs.readdirSync(currentDir, { withFileTypes: true });

      for (const item of items) {
        const fullPath = path.join(currentDir, item.name);

        if (item.isDirectory()) {
          if (!item.name.startsWith('.') && !ignoreDirs.includes(item.name)) {
            walk(fullPath, depth + 1);
          }
        } else if (item.isFile()) {
          if (extensions.some((ext) => item.name.endsWith(ext))) {
            try {
              const stats = fs.statSync(fullPath);

              // Calculate path-based score first (fast)
              const pathScore = calculatePathRelevance(fullPath, keywords);

              files.push({
                path: fullPath,
                size: stats.size,
                pathScore,
                contentScore: 0, // Will be calculated later for top candidates
                relevanceScore: pathScore,
                matchedKeywords: [],
              });
            } catch {
              // Skip files we can't stat
            }
          }
        }

        if (files.length >= 200) return; // Cap at 200 files for initial scan
      }
    } catch {
      // Skip directories we can't read
    }
  }

  walk(dir);

  // Sort by path score first
  files.sort((a, b) => b.pathScore - a.pathScore);

  // Content search on top 50 candidates (performance optimization)
  const topCandidates = files.slice(0, 50);

  console.log('   ğŸ” Searching file contents for keywords...');

  for (const file of topCandidates) {
    const { score: contentScore, matchedKeywords } = searchFileContent(file.path, searchContext);
    file.contentScore = contentScore;
    file.matchedKeywords = matchedKeywords;
    // Combined score: content is weighted higher (2x) than path
    file.relevanceScore = file.pathScore + (file.contentScore * 2);
  }

  // Re-sort by combined relevance score
  topCandidates.sort((a, b) => b.relevanceScore - a.relevanceScore);

  // Log top matches for debugging
  const topMatches = topCandidates.slice(0, 5).filter(f => f.relevanceScore > 0);
  if (topMatches.length > 0) {
    console.log('   ğŸ“Š Content search results:');
    for (const match of topMatches) {
      console.log(`      - ${match.path} (score: ${match.relevanceScore}, keywords: ${match.matchedKeywords.slice(0, 3).join(', ')})`);
    }
  }

  return topCandidates.slice(0, config.maxFiles);
}

// ============================================
// Context Extraction
// ============================================

/**
 * Represents a specific error location extracted from stack traces
 */
interface ErrorLocation {
  file: string;        // File path or name
  line?: number;       // Line number (if available)
  column?: number;     // Column number (if available)
  functionName?: string; // Function name (if available)
  context?: string;    // Surrounding context from error message
}

/**
 * Extract error locations from stack traces and error messages
 * Supports multiple stack trace formats:
 * - Node.js: "at functionName (file.js:10:5)"
 * - Chrome: "at functionName (http://localhost:3000/file.js:10:5)"
 * - Firefox: "functionName@file.js:10:5"
 * - React: "at ComponentName (file.tsx:10:5)"
 * - Python: 'File "file.py", line 10, in function_name'
 * - Generic: "file.ts:10" or "file.ts:10:5"
 */
function extractErrorLocations(text: string): ErrorLocation[] {
  const locations: ErrorLocation[] = [];
  const seenFiles = new Set<string>();

  // Pattern 1: Node.js/Chrome/React style - "at func (file:line:col)" or "at file:line:col"
  const nodePattern = /at\s+(?:(\w[\w.<>]*)\s+)?\(?(?:https?:\/\/[^/]+)?([^:)\s]+):(\d+):(\d+)\)?/g;
  let match;
  while ((match = nodePattern.exec(text)) !== null) {
    const file = match[2] || '';
    if (file && !seenFiles.has(file)) {
      seenFiles.add(file);
      locations.push({
        file: path.basename(file),
        line: parseInt(match[3] || '0', 10),
        column: parseInt(match[4] || '0', 10),
        functionName: match[1],
      });
    }
  }

  // Pattern 2: Firefox style - "functionName@file:line:col"
  const firefoxPattern = /(\w+)@([^:]+):(\d+):(\d+)/g;
  while ((match = firefoxPattern.exec(text)) !== null) {
    const file = match[2] || '';
    if (file && !seenFiles.has(file)) {
      seenFiles.add(file);
      locations.push({
        file: path.basename(file),
        line: parseInt(match[3] || '0', 10),
        column: parseInt(match[4] || '0', 10),
        functionName: match[1],
      });
    }
  }

  // Pattern 3: Python style - 'File "file.py", line 10'
  const pythonPattern = /File\s+"([^"]+)",\s+line\s+(\d+)(?:,\s+in\s+(\w+))?/g;
  while ((match = pythonPattern.exec(text)) !== null) {
    const file = match[1] || '';
    if (file && !seenFiles.has(file)) {
      seenFiles.add(file);
      locations.push({
        file: path.basename(file),
        line: parseInt(match[2] || '0', 10),
        functionName: match[3],
      });
    }
  }

  // Pattern 4: Generic "file.ext:line" or "file.ext:line:col"
  const genericPattern = /([\w./-]+\.(ts|tsx|js|jsx|py|go|rs|java|kt)):(\d+)(?::(\d+))?/g;
  while ((match = genericPattern.exec(text)) !== null) {
    const file = match[1] || '';
    if (file && !seenFiles.has(file)) {
      seenFiles.add(file);
      locations.push({
        file: path.basename(file),
        line: parseInt(match[3] || '0', 10),
        column: match[4] ? parseInt(match[4], 10) : undefined,
      });
    }
  }

  // Pattern 5: Webpack/bundler - "webpack:///./src/file.tsx"
  const webpackPattern = /webpack:\/\/\/\.\/([^?:]+)(?::(\d+))?/g;
  while ((match = webpackPattern.exec(text)) !== null) {
    const file = match[1] || '';
    if (file && !seenFiles.has(file)) {
      seenFiles.add(file);
      locations.push({
        file: path.basename(file),
        line: match[2] ? parseInt(match[2], 10) : undefined,
      });
    }
  }

  return locations;
}

/**
 * Extract error messages and their context
 */
function extractErrorMessages(text: string): string[] {
  const messages: string[] = [];

  // Common error patterns
  const patterns = [
    // JavaScript/TypeScript errors
    /(?:TypeError|ReferenceError|SyntaxError|RangeError|Error):\s*(.+?)(?:\n|$)/gi,
    // React errors
    /(?:Uncaught|Unhandled)\s+(?:Error|Exception):\s*(.+?)(?:\n|$)/gi,
    // Generic "error:" or "Error:" messages
    /(?:error|Error|ERROR):\s*(.+?)(?:\n|$)/g,
    // Failed assertions
    /(?:AssertionError|assertion failed):\s*(.+?)(?:\n|$)/gi,
    // Network errors
    /(?:NetworkError|FetchError|AxiosError):\s*(.+?)(?:\n|$)/gi,
    // HTTP status errors
    /(?:4\d{2}|5\d{2})\s+(?:error|Error)?:?\s*(.+?)(?:\n|$)/gi,
  ];

  for (const pattern of patterns) {
    let match;
    while ((match = pattern.exec(text)) !== null) {
      if (match[1] && match[1].length > 3) {
        messages.push(match[1].trim());
      }
    }
  }

  return [...new Set(messages)];
}

function extractKeywords(text: string): string[] {
  const keywords: string[] = [];

  // File paths
  // tsx/jsx before ts/js to prevent partial matches
  const filePathPattern = /(?:[\w-]+\/)*[\w-]+\.(tsx|ts|jsx|js|py|go|rs|java|kt)/g;
  keywords.push(...(text.match(filePathPattern) || []));

  // Error types
  const errorPattern = /(?:Error|Exception|TypeError|ReferenceError|SyntaxError|RuntimeError|NullPointerException)/g;
  keywords.push(...(text.match(errorPattern) || []));

  // Function/class names (PascalCase or camelCase)
  const identifierPattern = /\b[A-Z][a-zA-Z0-9]{2,}\b|\b[a-z]+[A-Z][a-zA-Z0-9]*\b/g;
  keywords.push(...(text.match(identifierPattern) || []).slice(0, 15));

  // Extract from error locations
  const locations = extractErrorLocations(text);
  keywords.push(...locations.map(loc => loc.file));
  keywords.push(...locations.filter(loc => loc.functionName).map(loc => loc.functionName!));

  return [...new Set(keywords)];
}

// ============================================
// AST-like Code Chunking (P3-1)
// ============================================

interface CodeChunk {
  type: 'function' | 'class' | 'interface' | 'type' | 'const' | 'export';
  name: string;
  startLine: number;
  endLine: number;
  content: string;
  signature: string;
}

/**
 * Extract logical code chunks from TypeScript/JavaScript source
 * Uses regex patterns to identify function, class, and interface boundaries
 * This is a lightweight alternative to full AST parsing
 */
function extractCodeChunks(content: string): CodeChunk[] {
  const lines = content.split('\n');
  const chunks: CodeChunk[] = [];

  // Track brace depth for finding block ends
  function findBlockEnd(startIdx: number): number {
    let depth = 0;
    let foundOpen = false;

    for (let i = startIdx; i < lines.length; i++) {
      const line = lines[i];
      for (const char of line) {
        if (char === '{') {
          depth++;
          foundOpen = true;
        } else if (char === '}') {
          depth--;
          if (foundOpen && depth === 0) {
            return i;
          }
        }
      }
    }
    return lines.length - 1;
  }

  // Patterns to identify chunk starts
  const patterns = [
    // Exported functions: export function name(...) or export async function name(...)
    { regex: /^export\s+(async\s+)?function\s+(\w+)\s*\(/m, type: 'function' as const, nameGroup: 2 },
    // Regular functions: function name(...) or async function name(...)
    { regex: /^(async\s+)?function\s+(\w+)\s*\(/m, type: 'function' as const, nameGroup: 2 },
    // Arrow functions: const name = (...) => or const name = async (...) =>
    { regex: /^(?:export\s+)?const\s+(\w+)\s*=\s*(async\s+)?\([^)]*\)\s*(:\s*[^=]+)?\s*=>/m, type: 'function' as const, nameGroup: 1 },
    // Classes: class Name or export class Name
    { regex: /^(?:export\s+)?class\s+(\w+)/m, type: 'class' as const, nameGroup: 1 },
    // Interfaces: interface Name
    { regex: /^(?:export\s+)?interface\s+(\w+)/m, type: 'interface' as const, nameGroup: 1 },
    // Type aliases: type Name =
    { regex: /^(?:export\s+)?type\s+(\w+)\s*=/m, type: 'type' as const, nameGroup: 1 },
  ];

  const processedLines = new Set<number>();

  for (let i = 0; i < lines.length; i++) {
    if (processedLines.has(i)) continue;

    const lineContent = lines[i].trim();
    if (!lineContent || lineContent.startsWith('//') || lineContent.startsWith('*')) continue;

    for (const pattern of patterns) {
      const match = lineContent.match(pattern.regex);
      if (match) {
        const name = match[pattern.nameGroup] || 'anonymous';
        const endLine = findBlockEnd(i);

        // Extract the chunk content
        const chunkLines = lines.slice(i, endLine + 1);
        const chunkContent = chunkLines.join('\n');

        // Extract signature (first line, cleaned up)
        const signature = lineContent.replace(/\{.*$/, '').trim();

        chunks.push({
          type: pattern.type,
          name,
          startLine: i + 1, // 1-indexed
          endLine: endLine + 1,
          content: chunkContent,
          signature,
        });

        // Mark these lines as processed
        for (let j = i; j <= endLine; j++) {
          processedLines.add(j);
        }
        break;
      }
    }
  }

  return chunks;
}

/**
 * Get relevant chunks from a file based on error locations and keywords
 */
function getRelevantChunks(
  filePath: string,
  errorLocations: ErrorLocation[],
  keywords: string[],
  maxChunks = 5
): CodeChunk[] {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const chunks = extractCodeChunks(content);

    if (chunks.length === 0) return [];

    // Score chunks by relevance
    const scoredChunks = chunks.map(chunk => {
      let score = 0;

      // Check if any error location falls within this chunk
      for (const loc of errorLocations) {
        if (loc.line && loc.line >= chunk.startLine && loc.line <= chunk.endLine) {
          score += 100; // High priority for error location match
        }
        if (loc.functionName && chunk.name.toLowerCase().includes(loc.functionName.toLowerCase())) {
          score += 50;
        }
      }

      // Check keyword matches
      const chunkLower = (chunk.name + ' ' + chunk.signature).toLowerCase();
      for (const keyword of keywords) {
        if (keyword.length > 2 && chunkLower.includes(keyword.toLowerCase())) {
          score += 10;
        }
      }

      // Boost for exported functions (more likely to be entry points)
      if (chunk.signature.startsWith('export')) {
        score += 5;
      }

      return { chunk, score };
    });

    // Sort by score and return top chunks
    return scoredChunks
      .filter(sc => sc.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, maxChunks)
      .map(sc => sc.chunk);
  } catch {
    return [];
  }
}

/**
 * Build context using AST-like chunks for more precise code selection
 */
function buildChunkedContext(
  relevantFiles: FileInfo[],
  errorLocations: ErrorLocation[],
  keywords: string[],
  maxTotalChars = 60000
): string {
  const contextParts: string[] = [];
  let totalChars = 0;

  for (const file of relevantFiles) {
    if (totalChars >= maxTotalChars) break;

    const chunks = getRelevantChunks(file.path, errorLocations, keywords);

    if (chunks.length > 0) {
      // Build chunk-based context
      let fileContext = `### ${file.path}\n`;

      for (const chunk of chunks) {
        const chunkHeader = `#### ${chunk.type}: ${chunk.name} (lines ${chunk.startLine}-${chunk.endLine})\n`;
        const chunkCode = `\`\`\`typescript\n${chunk.content}\n\`\`\`\n`;

        if (totalChars + chunkHeader.length + chunkCode.length < maxTotalChars) {
          fileContext += chunkHeader + chunkCode;
          totalChars += chunkHeader.length + chunkCode.length;
        }
      }

      if (fileContext.length > file.path.length + 10) {
        contextParts.push(fileContext);
      }
    }

    // Stop after processing top files
    if (contextParts.length >= 10) break;
  }

  return contextParts.join('\n\n');
}

function readFileWithContext(filePath: string, maxChars = 4000): string {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    const totalLines = lines.length;

    // If file is small enough, return all
    if (content.length <= maxChars) {
      return `### ${filePath} (${totalLines} lines)\n\`\`\`\n${content}\n\`\`\``;
    }

    // Otherwise, try to include important parts
    const truncated = content.slice(0, maxChars);
    const truncatedLines = truncated.split('\n').length;

    return `### ${filePath} (showing ${truncatedLines}/${totalLines} lines)\n\`\`\`\n${truncated}\n... (truncated)\n\`\`\``;
  } catch {
    return '';
  }
}

/**
 * Read file with focus on specific line numbers from error locations
 * Provides context around the error line for better analysis
 */
function readFileWithLineContext(
  filePath: string,
  targetLine: number,
  contextLines = 15, // Lines before and after
  maxChars = 5000
): string {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    const totalLines = lines.length;

    // Validate target line
    if (targetLine <= 0 || targetLine > totalLines) {
      return readFileWithContext(filePath, maxChars);
    }

    // Calculate range (1-indexed to 0-indexed)
    const startLine = Math.max(0, targetLine - 1 - contextLines);
    const endLine = Math.min(totalLines, targetLine - 1 + contextLines + 1);

    // Extract lines with line numbers
    const contextContent = lines
      .slice(startLine, endLine)
      .map((line, idx) => {
        const lineNum = startLine + idx + 1;
        const marker = lineNum === targetLine ? '>>>' : '   ';
        return `${marker} ${lineNum.toString().padStart(4)}: ${line}`;
      })
      .join('\n');

    const header = `### ${filePath} (lines ${startLine + 1}-${endLine} of ${totalLines}, error at line ${targetLine})`;

    return `${header}\n\`\`\`\n${contextContent}\n\`\`\``;
  } catch {
    return '';
  }
}

/**
 * Build prioritized code context from error locations and relevant files
 */
function buildCodeContext(
  relevantFiles: FileInfo[],
  errorLocations: ErrorLocation[],
  maxTotalChars = 60000
): string {
  const contextParts: string[] = [];
  let totalChars = 0;

  // Priority 1: Files directly from stack traces with line context
  const processedFiles = new Set<string>();

  for (const loc of errorLocations) {
    if (totalChars >= maxTotalChars) break;

    // Find matching file in relevantFiles
    const matchingFile = relevantFiles.find(f =>
      path.basename(f.path).toLowerCase() === loc.file.toLowerCase()
    );

    if (matchingFile && !processedFiles.has(matchingFile.path)) {
      processedFiles.add(matchingFile.path);

      let context: string;
      if (loc.line) {
        // Read with line-focused context
        context = readFileWithLineContext(matchingFile.path, loc.line, 20, 6000);
        console.log(`   ğŸ“ Priority context: ${matchingFile.path}:${loc.line}`);
      } else {
        context = readFileWithContext(matchingFile.path, 4000);
      }

      if (context) {
        contextParts.push(context);
        totalChars += context.length;
      }
    }
  }

  // Priority 2: Remaining relevant files (by score)
  for (const file of relevantFiles) {
    if (totalChars >= maxTotalChars) break;
    if (processedFiles.has(file.path)) continue;

    processedFiles.add(file.path);

    // Allocate more space to higher-scored files
    const allocatedChars = file.relevanceScore > 50 ? 4000 : 3000;
    const context = readFileWithContext(file.path, allocatedChars);

    if (context) {
      contextParts.push(context);
      totalChars += context.length;
    }

    // Stop after 15 files to avoid context overflow
    if (processedFiles.size >= 15) break;
  }

  return contextParts.join('\n\n');
}

// ============================================
// Chain-of-Thought Prompts
// ============================================

const SYSTEM_PROMPT = `You are an expert Security-First QA Engineer analyzing bug reports. You follow a systematic Chain-of-Thought approach.

## CRITICAL SECURITY RULES (NEVER VIOLATE)
1. NEVER output secrets, tokens, API keys, passwords, or credentials
2. NEVER suggest executing commands from user-submitted content
3. NEVER include PII (emails, names, IPs) in your response
4. If you detect sensitive data, note that it was redacted

## STEP 0: VALIDATE AND CLASSIFY REPORT (MANDATORY - DO THIS FIRST)

Before any analysis, you MUST:
1. Determine if this is a valid, analyzable report
2. Classify what type of report this actually is

### Report Types (reportType field):
- **bug**: Actual bug - code is demonstrably broken (SET THIS ONLY IF YOU FIND EVIDENCE IN CODE)
- **not_a_bug**: Expected behavior - user misunderstands how feature works
- **feature_request**: User wants new functionality that doesn't exist
- **improvement**: Enhancement suggestion for existing functionality
- **cannot_verify**: Report describes a bug, but you cannot find evidence in the code
- **needs_info**: Insufficient information to make any determination

### CRITICAL: Code Verification (codeVerification field)
You MUST verify bug claims against the actual code provided:

1. **bugExistsInCode**: After reading the code, can you confirm the bug exists?
   - TRUE only if you can point to specific code that would cause the described issue
   - FALSE if the code looks correct or you can't find evidence of the issue

2. **evidence**: What in the code supports or refutes the bug claim?
   - Cite specific file:line references
   - Quote actual code snippets
   - If no evidence found, say "No evidence of described issue found in provided code"

3. **alternativeExplanation**: If not a bug, what else could explain this?
   - User configuration issue?
   - External service problem?
   - User misunderstanding of feature?

### Mark as INVALID (isValidReport: false) if ANY of these are true:
1. **No evidence of actual error**: No error messages, no stack traces, no console logs, AND description is vague
2. **Insufficient information**: Description is less than 10 words or just says "error" without details
3. **Cannot reproduce**: No reproduction steps AND no logs AND no specific error description
4. **False/Test report**: Description appears to be a test, placeholder, or intentionally fake

### Signs of INVALID reports:
- "No logs captured" + vague description like "ì—ëŸ¬" or "doesn't work"
- Description only contains generic words without specific symptoms
- No URL context + no logs + no error messages

### When codeVerification.bugExistsInCode is FALSE:
Even if the report seems valid, if you cannot find evidence in the code:
- Set reportType: "cannot_verify" or "not_a_bug"
- Do NOT suggest code fixes for bugs you cannot verify
- Instead, suggest debugging steps or request more information

**Only suggest code fixes when you have CONFIRMED the bug exists in the code**

## ANALYSIS METHODOLOGY (Chain-of-Thought) - Only for VALID reports

### Step 1: UNDERSTAND
- Read the bug report carefully
- Identify the symptoms (what is happening)
- Identify the expected behavior (what should happen)
- Note any error messages or stack traces

### Step 2: HYPOTHESIZE
- Based on symptoms, form hypotheses about root causes
- Consider common bug patterns for this type of issue
- Rank hypotheses by likelihood

### Step 3: INVESTIGATE
- Examine the provided code context
- Look for evidence supporting or refuting each hypothesis
- Trace the data/control flow

### Step 4: CONCLUDE
- Identify the most likely root cause with evidence
- Determine the specific file(s) and line(s) involved
- Assess the severity and impact

### Step 5: RECOMMEND
- Provide specific, actionable fix steps
- Include code changes when possible
- Suggest preventive measures

## OUTPUT QUALITY REQUIREMENTS
- Be specific and actionable, not generic
- Reference actual file names and code from the context
- Provide working code snippets, not pseudocode
- Explain WHY the fix works, not just WHAT to change
- DO NOT fabricate issues that don't exist in the code
- If you cannot find evidence of a bug, say so honestly

## EVIDENCE-BASED ANALYSIS RULES (P3-2 Enhancement)

### Rule 1: Code Location Citation (MANDATORY)
Every claim about the code MUST include a precise location reference:
- Format: \`filename.ts:lineNumber\` (e.g., \`server.ts:42\`)
- When suggesting fixes, specify the exact line range to modify
- If line numbers are marked with >>> in the context, prioritize those lines

### Rule 2: Evidence Chain
Build a traceable path from error to root cause:
1. **Error Point**: Where the error manifests (from stack trace or logs)
2. **Call Path**: How execution reached that point
3. **Root Cause**: The actual source of the bug
Each step must cite code evidence.

### Rule 3: Confidence Calibration
Your confidence score MUST reflect actual evidence quality:
- **90-100%**: Stack trace points directly to the issue + code clearly shows the bug
- **70-89%**: Strong circumstantial evidence from code patterns
- **50-69%**: Reasonable inference but missing direct evidence
- **Below 50%**: Speculative - state this clearly and request more info

### Rule 4: Counter-Evidence Check
Before finalizing analysis, ask yourself:
- "What evidence would DISPROVE this hypothesis?"
- "Are there alternative explanations for this behavior?"
- "What assumptions am I making that might be wrong?"
If counter-evidence exists, mention it and explain why your conclusion is still valid.

### Rule 5: No Speculation Without Disclosure
If you must speculate (due to incomplete information):
- Prefix with "âš ï¸ Speculative:" or similar marker
- Explain what additional information would confirm/deny the speculation
- Lower confidence score accordingly

## MULTIPLE ROOT CAUSES (analyses array)

The output schema supports multiple root cause analyses. Use this when:

### When to return MULTIPLE analyses (2-3):
- The bug report describes multiple distinct issues (e.g., "login fails AND profile page crashes")
- You find evidence of unrelated bugs in the same code area
- The symptoms could be caused by completely different root causes

### When to return SINGLE analysis (1):
- There is one clear root cause
- Multiple symptoms trace back to the same underlying issue
- You're not confident about alternative causes

### Guidelines:
- Order analyses by likelihood (most likely first)
- Each analysis should be INDEPENDENT and COMPLETE with its own:
  - severity, category, codeVerification
  - rootCause (summary, explanation, affectedFiles)
  - suggestedFix (steps, codeChanges)
  - prevention, confidence, additionalContext
- Do NOT split one issue into multiple analyses just to fill the array
- Maximum 3 analyses - if more potential causes exist, mention them in additionalContext`;

/**
 * Get the system prompt with language-specific instructions
 */
function getSystemPrompt(language: OutputLanguage): string {
  const languageName = LANGUAGE_NAMES[language];

  // Language-specific instructions
  const languageInstructions = language === 'en' ? '' : `

## OUTPUT LANGUAGE REQUIREMENT

**CRITICAL: You MUST write ALL analysis output in ${languageName}.**

This includes:
- rootCause.summary and rootCause.explanation
- suggestedFix.steps and suggestedFix.codeChanges[].description
- prevention items
- additionalContext
- codeVerification.evidence and codeVerification.alternativeExplanation
- invalidReason (if applicable)

**Exceptions (keep in English):**
- File paths and code snippets
- Technical terms that don't have standard translations
- Variable/function names from the codebase

Example for Korean (ko):
- rootCause.summary: "ì‚¬ìš©ì ì…ë ¥ê°’ ê²€ì¦ ëˆ„ë½ìœ¼ë¡œ ì¸í•œ null ì°¸ì¡° ì˜¤ë¥˜"
- suggestedFix.steps: ["1. UserService.tsì˜ validateInput í•¨ìˆ˜ì— null ì²´í¬ ì¶”ê°€", "2. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±"]`;

  return SYSTEM_PROMPT + languageInstructions;
}

const USER_PROMPT_TEMPLATE = (
  title: string,
  body: string,
  codeContext: string,
  keywords: string[]
) => `Analyze this bug report using the Chain-of-Thought methodology:

## Bug Report

### Title
${title}

### Description
${body}

### Extracted Keywords
${keywords.join(', ')}

## Code Context
${codeContext || 'No relevant code files found in the repository.'}

---

Please analyze this bug step-by-step following the methodology, then provide your structured analysis.`;

// ============================================
// Retry Logic
// ============================================

async function withRetry<T>(
  fn: () => Promise<T>,
  maxAttempts: number,
  delayMs: number
): Promise<T> {
  let lastError: Error | undefined;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      console.log(`âš ï¸ Attempt ${attempt}/${maxAttempts} failed: ${lastError.message}`);

      if (attempt < maxAttempts) {
        const waitTime = delayMs * Math.pow(2, attempt - 1); // Exponential backoff
        console.log(`â³ Waiting ${waitTime}ms before retry...`);
        await new Promise((resolve) => setTimeout(resolve, waitTime));
      }
    }
  }

  throw lastError;
}

// ============================================
// Self-Consistency Verification (P3-2)
// ============================================

/**
 * Calculate similarity between two root cause summaries
 * Uses simple word overlap as a heuristic
 */
function calculateSimilarity(text1: string, text2: string): number {
  const normalize = (t: string) => t.toLowerCase().replace(/[^a-z0-9ê°€-í£\s]/g, '');
  const words1 = new Set(normalize(text1).split(/\s+/).filter(w => w.length > 2));
  const words2 = new Set(normalize(text2).split(/\s+/).filter(w => w.length > 2));

  if (words1.size === 0 || words2.size === 0) return 0;

  let intersection = 0;
  for (const word of words1) {
    if (words2.has(word)) intersection++;
  }

  // Jaccard similarity
  const union = words1.size + words2.size - intersection;
  return union > 0 ? intersection / union : 0;
}

/**
 * Check if multiple analysis results are consistent
 * Returns the most common result with consistency metadata
 */
function checkConsistency(
  results: AnalysisResult[],
  threshold: number
): { result: AnalysisResult; isConsistent: boolean; agreementRate: number } {
  if (results.length === 0) {
    throw new Error('No results to check consistency');
  }

  if (results.length === 1) {
    return { result: results[0], isConsistent: true, agreementRate: 1.0 };
  }

  // Group by validity first
  const validResults = results.filter(r => r.isValidReport);
  const invalidResults = results.filter(r => !r.isValidReport);

  // If majority says invalid, use that
  if (invalidResults.length > validResults.length) {
    return {
      result: invalidResults[0],
      isConsistent: invalidResults.length === results.length,
      agreementRate: invalidResults.length / results.length,
    };
  }

  // For valid reports, check root cause similarity (using first analysis)
  const summaries = validResults.map(r => r.analyses[0]?.rootCause.summary || '');
  const similarityMatrix: number[][] = [];

  for (let i = 0; i < summaries.length; i++) {
    similarityMatrix[i] = [];
    for (let j = 0; j < summaries.length; j++) {
      similarityMatrix[i][j] = i === j ? 1 : calculateSimilarity(summaries[i], summaries[j]);
    }
  }

  // Find the result with highest average similarity to others
  let bestIdx = 0;
  let bestAvgSim = 0;
  for (let i = 0; i < summaries.length; i++) {
    const avgSim = similarityMatrix[i].reduce((a, b) => a + b, 0) / summaries.length;
    if (avgSim > bestAvgSim) {
      bestAvgSim = avgSim;
      bestIdx = i;
    }
  }

  // Count how many agree with the best result
  const agreementCount = similarityMatrix[bestIdx].filter(sim => sim >= 0.5).length;
  const agreementRate = agreementCount / results.length;

  return {
    result: validResults[bestIdx],
    isConsistent: agreementRate >= threshold,
    agreementRate,
  };
}

/**
 * Run analysis with self-consistency verification
 * Generates multiple analyses and checks for agreement
 */
async function analyzeWithConsistency(
  generateFn: () => Promise<AnalysisResult>,
  numSamples: number,
  threshold: number
): Promise<AnalysisResult> {
  console.log(`   ğŸ”„ Running ${numSamples} parallel analyses for consistency check...`);

  // Run analyses in parallel
  const promises = Array(numSamples).fill(null).map(() => generateFn());
  const results = await Promise.allSettled(promises);

  const successfulResults: AnalysisResult[] = [];
  for (const result of results) {
    if (result.status === 'fulfilled') {
      successfulResults.push(result.value);
    }
  }

  if (successfulResults.length === 0) {
    throw new Error('All consistency samples failed');
  }

  // Check consistency
  const { result, isConsistent, agreementRate } = checkConsistency(successfulResults, threshold);

  console.log(`   ğŸ“Š Agreement rate: ${(agreementRate * 100).toFixed(0)}% (${successfulResults.length} samples)`);

  if (!isConsistent) {
    console.log(`   âš ï¸ Low consistency detected - adding warning to result`);
    // Adjust the result to indicate low consistency - update each analysis in the array
    const warningMessage = `\n\nâš ï¸ **Consistency Warning**: Multiple analysis runs showed ${(agreementRate * 100).toFixed(0)}% agreement. ` +
      `This analysis may benefit from manual verification.`;

    return {
      ...result,
      analyses: result.analyses.map(analysis => ({
        ...analysis,
        confidence: Math.min(analysis.confidence, 50),
        additionalContext: (analysis.additionalContext || '') + warningMessage,
      })),
    };
  }

  console.log(`   âœ… High consistency confirmed`);
  return result;
}

// ============================================
// Analysis Result Formatting
// ============================================

interface FormatOptions {
  provider: string;
  model: string;
  filesAnalyzed: number;
  analysisIndex?: number;  // 1-based index for multiple analyses
  totalAnalyses?: number;  // Total number of analyses
  language: OutputLanguage;  // Output language for i18n
}

/**
 * Format comment for invalid/insufficient reports
 */
function formatInvalidReportComment(
  invalidReason: string | undefined,
  options: FormatOptions
): string {
  const modelDisplay = options.model || DEFAULT_MODELS[options.provider as AIProvider] || 'default';
  const t = getI18n(options.language);

  return `## ğŸ” ${t.analysisTitle}

âšª **${t.reportStatus}:** ${t.insufficientInfo}

---

### â“ ${t.unableToAnalyze}

${t.insufficientInfoReason}

**Reason:** ${invalidReason || t.insufficientInfoReason}

---

### ğŸ“ ${t.whatWeNeed}

1. **${t.errorMessages}**
2. **${t.stepsToReproduce}**
3. **${t.expectedVsActual}**
4. **${t.consoleLogs}**

---

### ğŸ”„ ${t.nextSteps}

- ${t.updateIssue}
- ${t.submitNewReport}

---

<details>
<summary>${t.analysisMetadata}</summary>

| Field | Value |
|-------|-------|
| Status | ${t.insufficientInfo} |
| ${t.provider} | ${options.provider} |
| ${t.model} | ${modelDisplay} |
| ${t.filesAnalyzed} | ${options.filesAnalyzed} |
| ${t.timestamp} | ${new Date().toISOString()} |

</details>

*${t.generatedBy} [inner-lens](https://github.com/jhlee0409/inner-lens).*`;
}

/**
 * Format comment for non-bug reports (feature requests, not a bug, etc.)
 */
function formatNonBugReportComment(
  reportType: AnalysisResult['reportType'],
  analysis: RootCauseAnalysis,
  options: FormatOptions
): string {
  const modelDisplay = options.model || DEFAULT_MODELS[options.provider as AIProvider] || 'default';
  const t = getI18n(options.language);

  const reportTypeLabels: Record<string, { emoji: string; label: string }> = {
    bug: { emoji: 'ğŸ›', label: t.confirmedBug },
    not_a_bug: { emoji: 'âœ…', label: t.notABug },
    feature_request: { emoji: 'ğŸ’¡', label: t.featureRequest },
    improvement: { emoji: 'ğŸ”§', label: t.improvementSuggestion },
    cannot_verify: { emoji: 'ğŸ”', label: t.cannotVerify },
    needs_info: { emoji: 'â“', label: t.needsMoreInfo },
  };

  const reportTypeInfo = reportTypeLabels[reportType] || reportTypeLabels.cannot_verify;

  return `## ğŸ” ${t.analysisTitle}

${reportTypeInfo.emoji} **${t.classification}:** ${reportTypeInfo.label}

---

### ğŸ“‹ ${t.analysisResult}

${analysis.codeVerification?.bugExistsInCode === false
  ? `**${t.codeVerification}:** âŒ ${t.noBugFound}

${analysis.codeVerification.evidence}

${analysis.codeVerification.alternativeExplanation ? `**${t.possibleExplanation}:** ${analysis.codeVerification.alternativeExplanation}` : ''}`
  : `${analysis.rootCause.explanation}`}

---

${reportType === 'feature_request' || reportType === 'improvement' ? `### ğŸ’¡ ${t.recommendation}

${t.featureRequestNote}
` : ''}

${reportType === 'not_a_bug' ? `### âœ… ${t.expectedBehavior}

${t.workingAsDesigned}

${analysis.codeVerification?.alternativeExplanation || ''}
` : ''}

${reportType === 'cannot_verify' ? `### ğŸ” ${t.unableToConfirm}

**${t.whatThisMeans}:**
- ${t.bugMayExist}
- ${t.environmentSpecific}
- ${t.moreInfoNeeded}

**${t.suggestedNextSteps}:**
1. ${t.provideConsoleLogs}
2. ${t.shareStepsToReproduce}
3. ${t.includeExactError}
` : ''}

---

<details>
<summary>${t.analysisMetadata}</summary>

| Field | Value |
|-------|-------|
| ${t.classification} | ${reportTypeInfo.label} |
| ${t.bugFoundInCode} | ${analysis.codeVerification?.bugExistsInCode ? t.yes : t.no} |
| ${t.confidence} | ${analysis.confidence}% |
| ${t.provider} | ${options.provider} |
| ${t.model} | ${modelDisplay} |
| ${t.filesAnalyzed} | ${options.filesAnalyzed} |
| ${t.timestamp} | ${new Date().toISOString()} |

</details>

*${t.generatedBy} [inner-lens](https://github.com/jhlee0409/inner-lens). ${t.verifyBeforeApplying}*`;
}

/**
 * Format comment for a single root cause analysis (bug report)
 */
function formatRootCauseComment(
  analysis: RootCauseAnalysis,
  options: FormatOptions
): string {
  const modelDisplay = options.model || DEFAULT_MODELS[options.provider as AIProvider] || 'default';
  const t = getI18n(options.language);

  const severityEmoji: Record<string, string> = {
    critical: 'ğŸ”´',
    high: 'ğŸŸ ',
    medium: 'ğŸŸ¡',
    low: 'ğŸŸ¢',
    none: 'âšª',
  };

  const categoryLabels: Record<string, string> = {
    runtime_error: t.runtimeError,
    logic_error: t.logicError,
    performance: t.performanceIssue,
    security: t.securityIssue,
    ui_ux: t.uiUxIssue,
    configuration: t.configurationIssue,
    invalid_report: t.invalidReport,
    unknown: t.unknown,
  };

  const codeChangesSection = analysis.suggestedFix.codeChanges
    .map((change) => {
      let section = `#### ğŸ“„ \`${change.file}\`\n${change.description}\n`;
      if (change.before) {
        section += `\n**${t.before}:**\n\`\`\`\n${change.before}\n\`\`\`\n`;
      }
      section += `\n**${t.after}:**\n\`\`\`\n${change.after}\n\`\`\``;
      return section;
    })
    .join('\n\n');

  // Show analysis number if there are multiple analyses
  const analysisHeader = options.totalAnalyses && options.totalAnalyses > 1
    ? `## ğŸ” ${t.analysisTitle} (${options.analysisIndex}/${options.totalAnalyses})`
    : `## ğŸ” ${t.analysisTitle}`;

  return `${analysisHeader}

${severityEmoji[analysis.severity]} **${t.severity}:** ${analysis.severity.toUpperCase()} | **${t.category}:** ${categoryLabels[analysis.category]} | **${t.confidence}:** ${analysis.confidence}%

---

### ğŸ¯ ${t.rootCause}

**${analysis.rootCause.summary}**

${analysis.rootCause.explanation}

${analysis.rootCause.affectedFiles.length > 0 ? `**${t.affectedFiles}:** ${analysis.rootCause.affectedFiles.map(f => `\`${f}\``).join(', ')}` : ''}

---

### ğŸ”§ ${t.suggestedFix}

${analysis.suggestedFix.steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

${codeChangesSection ? `\n#### ${t.codeChanges}\n\n${codeChangesSection}` : ''}

---

### ğŸ›¡ï¸ ${t.prevention}

${analysis.prevention.map((p) => `- ${p}`).join('\n')}

${analysis.additionalContext ? `\n---\n\n### ğŸ“ ${t.additionalNotes}\n\n${analysis.additionalContext}` : ''}

---

<details>
<summary>${t.analysisMetadata}</summary>

| Field | Value |
|-------|-------|
| ${t.provider} | ${options.provider} |
| ${t.model} | ${modelDisplay} |
| ${t.filesAnalyzed} | ${options.filesAnalyzed} |
| ${t.timestamp} | ${new Date().toISOString()} |
| ${t.confidence} | ${analysis.confidence}% |
${options.totalAnalyses && options.totalAnalyses > 1 ? `| ${t.analysis} | ${options.analysisIndex} / ${options.totalAnalyses} |` : ''}

</details>

*${t.generatedBy} [inner-lens](https://github.com/jhlee0409/inner-lens). ${t.verifyBeforeApplying}*`;
}

// ============================================
// Main Analysis Function
// ============================================

async function analyzeIssue(): Promise<void> {
  console.log('ğŸ” inner-lens Analysis Engine v2 Starting...\n');
  console.log(`ğŸ“‹ Issue: ${config.owner}/${config.repo}#${config.issueNumber}`);
  console.log(`ğŸ¤– Provider: ${config.provider}`);
  console.log(`ğŸŒ Language: ${LANGUAGE_NAMES[config.language]}`);

  if (!config.issueNumber || !config.owner || !config.repo) {
    throw new Error('Missing required environment variables: ISSUE_NUMBER, REPO_OWNER, REPO_NAME');
  }

  const octokit = new Octokit({ auth: process.env['GITHUB_TOKEN'] });

  // Step 1: Fetch issue
  console.log('\nğŸ“¥ Step 1: Fetching issue details...');
  const { data: issue } = await octokit.issues.get({
    owner: config.owner,
    repo: config.repo,
    issue_number: config.issueNumber,
  });

  const maskedTitle = maskSensitiveData(issue.title);
  const maskedBody = maskSensitiveData(issue.body || '');
  console.log(`   Title: ${maskedTitle.slice(0, 80)}...`);

  // Step 2: Extract context from issue
  console.log('\nğŸ”‘ Step 2: Extracting context...');

  const issueText = `${issue.title} ${issue.body || ''}`;

  // 2a. Extract error locations from stack traces
  const errorLocations = extractErrorLocations(issueText);
  if (errorLocations.length > 0) {
    console.log(`   ğŸ“ Found ${errorLocations.length} error locations from stack trace:`);
    errorLocations.slice(0, 3).forEach(loc => {
      console.log(`      - ${loc.file}${loc.line ? `:${loc.line}` : ''}${loc.functionName ? ` (${loc.functionName})` : ''}`);
    });
  } else {
    console.log('   ğŸ“ No stack trace locations found');
  }

  // 2b. Extract error messages
  const errorMessages = extractErrorMessages(issueText);
  if (errorMessages.length > 0) {
    console.log(`   ğŸ’¬ Found ${errorMessages.length} error messages:`);
    errorMessages.slice(0, 2).forEach(msg => {
      console.log(`      - "${msg.slice(0, 60)}${msg.length > 60 ? '...' : ''}"`);
    });
  }

  // 2c. Extract general keywords
  const keywords = extractKeywords(issueText);
  console.log(`   ğŸ”¤ Found ${keywords.length} keywords: ${keywords.slice(0, 5).join(', ')}...`);

  // Step 3: Find relevant files using enhanced search
  console.log('\nğŸ“‚ Step 3: Finding relevant files...');
  let relevantFiles = findRelevantFiles('.', keywords, errorLocations, errorMessages);
  console.log(`   Found ${relevantFiles.length} relevant files`);

  if (relevantFiles.length > 0) {
    console.log('   Top 5 by relevance:');
    relevantFiles.slice(0, 5).forEach((f, i) => {
      const matchInfo = f.matchedKeywords.length > 0 ? ` [${f.matchedKeywords.slice(0, 2).join(', ')}]` : '';
      console.log(`   ${i + 1}. ${f.path} (score: ${f.relevanceScore})${matchInfo}`);
    });
  }

  // Step 3.5: Expand with import graph (P1-1)
  console.log('\nğŸ”— Step 3.5: Building import graph...');
  const importGraph = buildImportGraph(relevantFiles, '.');
  console.log(`   Parsed imports from ${importGraph.size} files`);

  if (importGraph.size > 0) {
    const originalCount = relevantFiles.length;
    relevantFiles = expandFilesWithImports(relevantFiles, importGraph);
    const addedCount = relevantFiles.length - originalCount;

    if (addedCount > 0) {
      console.log(`   Added ${addedCount} imported dependencies:`);
      relevantFiles.slice(originalCount, originalCount + 5).forEach((f) => {
        console.log(`      + ${f.path} (${f.matchedKeywords[0] || 'dependency'})`);
      });
    } else {
      console.log('   No new dependencies found');
    }
  }

  // Step 3.6: LLM Re-ranking (P1-2)
  console.log('\nğŸ¯ Step 3.6: LLM re-ranking candidates...');
  const beforeRerank = relevantFiles.slice(0, 5).map(f => f.path);
  relevantFiles = await rerankFilesWithLLM(
    relevantFiles,
    maskedTitle,
    maskedBody
  );
  const afterRerank = relevantFiles.slice(0, 5).map(f => f.path);

  // Check if ranking changed
  const rankChanged = beforeRerank.some((p, i) => afterRerank[i] !== p);
  if (rankChanged) {
    console.log('   âœ… Re-ranking applied. New top 5:');
    relevantFiles.slice(0, 5).forEach((f, i) => {
      const isReranked = f.matchedKeywords.includes('llm-reranked');
      console.log(`   ${i + 1}. ${f.path} (score: ${f.relevanceScore})${isReranked ? ' ğŸ”„' : ''}`);
    });
  } else {
    console.log('   Original ranking maintained');
  }

  // Step 4: Build code context with priority on error locations
  console.log('\nğŸ“– Step 4: Building code context...');

  let codeContext: string;

  // Use AST-like chunking if enabled (P3-1)
  if (config.useChunking) {
    console.log('   ğŸ“¦ Using AST-like code chunking (P3-1)');
    const chunkedContext = buildChunkedContext(relevantFiles, errorLocations, keywords, 60000);

    // If chunking found relevant chunks, use it; otherwise fallback to line-based
    if (chunkedContext.length > 500) {
      codeContext = chunkedContext;
      console.log('   âœ… Code chunks extracted successfully');
    } else {
      console.log('   âš ï¸ Insufficient chunks found, falling back to line-based context');
      codeContext = buildCodeContext(relevantFiles, errorLocations, 60000);
    }
  } else {
    codeContext = buildCodeContext(relevantFiles, errorLocations, 60000);
  }

  const contextSize = codeContext.length;
  console.log(`   Context size: ${(contextSize / 1024).toFixed(1)} KB`);

  // Step 5: Generate analysis with retry
  console.log('\nğŸ¤– Step 5: Generating AI analysis...');
  const model = getModel();

  const userPrompt = USER_PROMPT_TEMPLATE(maskedTitle, maskedBody, codeContext, keywords);

  // Single analysis generation function
  const generateAnalysis = async (): Promise<AnalysisResult> => {
    const { object } = await generateObject({
      model,
      schema: AnalysisResultSchema,
      system: getSystemPrompt(config.language),
      prompt: userPrompt,
      maxTokens: config.maxTokens,
    });
    return object;
  };

  let analysis: AnalysisResult;

  try {
    // Use self-consistency if enabled (P3-2)
    if (config.selfConsistency) {
      console.log('   ğŸ”„ Self-consistency mode enabled');
      analysis = await analyzeWithConsistency(
        () => withRetry(generateAnalysis, config.retryAttempts, config.retryDelay),
        config.consistencySamples,
        config.consistencyThreshold
      );
    } else {
      // Standard single analysis
      const result = await withRetry(generateAnalysis, config.retryAttempts, config.retryDelay);
      analysis = result;
    }
    console.log('   âœ… Structured analysis generated');
  } catch (structuredError) {
    // Fallback to text generation if structured fails
    console.log('   âš ï¸ Structured output failed, falling back to text generation...');

    const { text } = await withRetry(
      async () =>
        generateText({
          model,
          system: getSystemPrompt(config.language),
          prompt: userPrompt + '\n\nProvide your analysis in a structured format.',
          maxTokens: config.maxTokens,
        }),
      config.retryAttempts,
      config.retryDelay
    );

    // Create a basic structured result from text (using new schema with analyses array)
    analysis = {
      isValidReport: true, // Assume valid if we got this far
      reportType: 'cannot_verify', // Conservative default for fallback
      analyses: [{
        severity: 'medium',
        category: 'unknown',
        codeVerification: {
          bugExistsInCode: false,
          evidence: 'Unable to perform structured code verification (fallback mode)',
        },
        rootCause: {
          summary: 'Analysis generated from unstructured response',
          explanation: text,
          affectedFiles: relevantFiles.slice(0, 3).map((f) => f.path),
        },
        suggestedFix: {
          steps: ['Review the analysis above', 'Identify the specific changes needed', 'Implement and test the fix'],
          codeChanges: [],
        },
        prevention: ['Add automated tests for this scenario', 'Consider adding error handling'],
        confidence: 50,
        additionalContext: 'This analysis was generated using fallback text mode. Structured output was not available.',
      }],
    };
    console.log('   âœ… Fallback analysis generated');
  }

  // Step 5.5: Apply confidence calibration (2025 Enhancement)
  console.log('\nğŸ“Š Step 5.5: Calibrating confidence scores...');
  const { result: calibratedAnalysis, calibrationReports } = calibrateAllAnalyses(
    analysis,
    errorLocations
  );
  analysis = calibratedAnalysis;

  // Log calibration results
  let calibrationCount = 0;
  for (let i = 0; i < calibrationReports.length; i++) {
    const report = calibrationReports[i];
    if (report && report.wasCalibrated) {
      calibrationCount++;
      console.log(`   Analysis ${i + 1}: ${report.originalConfidence}% â†’ ${report.calibratedConfidence}%`);
      if (report.penalties.length > 0) {
        report.penalties.forEach(p => console.log(`      - ${p}`));
      }
    }
  }
  if (calibrationCount === 0) {
    console.log('   âœ… No calibration needed (confidence scores are appropriate)');
  } else {
    console.log(`   âš ï¸ Calibrated ${calibrationCount} analysis(es) for accuracy`);
  }

  // Step 6: Post comments (one per root cause analysis)
  console.log('\nğŸ’¬ Step 6: Posting analysis comments...');

  const formatOptions: FormatOptions = {
    provider: config.provider,
    model: config.model,
    filesAnalyzed: relevantFiles.length,
    language: config.language,
  };

  // Handle invalid reports - single comment
  if (!analysis.isValidReport) {
    const commentBody = formatInvalidReportComment(analysis.invalidReason, formatOptions);
    await octokit.issues.createComment({
      owner: config.owner,
      repo: config.repo,
      issue_number: config.issueNumber,
      body: commentBody,
    });
    console.log('   ğŸ“ Posted invalid report comment');
  }
  // Handle non-bug reports - single comment using first analysis
  else if (analysis.reportType !== 'bug') {
    const firstAnalysis = analysis.analyses[0];
    if (firstAnalysis) {
      const commentBody = formatNonBugReportComment(analysis.reportType, firstAnalysis, formatOptions);
      await octokit.issues.createComment({
        owner: config.owner,
        repo: config.repo,
        issue_number: config.issueNumber,
        body: commentBody,
      });
      console.log('   ğŸ“ Posted non-bug report comment');
    }
  }
  // Handle bug reports - one comment per root cause analysis
  else {
    const totalAnalyses = analysis.analyses.length;
    console.log(`   ğŸ“Š Found ${totalAnalyses} root cause(s) to report`);

    for (let i = 0; i < totalAnalyses; i++) {
      const rootCauseAnalysis = analysis.analyses[i];
      if (!rootCauseAnalysis) continue;

      const commentBody = formatRootCauseComment(rootCauseAnalysis, {
        ...formatOptions,
        analysisIndex: i + 1,
        totalAnalyses,
      });

      await octokit.issues.createComment({
        owner: config.owner,
        repo: config.repo,
        issue_number: config.issueNumber,
        body: commentBody,
      });
      console.log(`   ğŸ“ Posted analysis comment ${i + 1}/${totalAnalyses}`);

      // Small delay between comments to avoid rate limiting
      if (i < totalAnalyses - 1) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
  }

  // Step 7: Add labels based on analysis
  // Label schema (inspired by Kubernetes, VS Code, React):
  // - type:     Issue type (bug, enhancement, invalid)
  // - severity: Urgency level (critical, high, medium, low)
  // - area:     Affected area (runtime, logic, performance, security, ui-ux, config)
  // - status:   Analysis state (analyzed, needs-info, needs-repro)
  // - ai:       AI verification (verified, unverified)
  console.log('\nğŸ·ï¸ Step 7: Adding labels...');
  const labelsToAdd: string[] = ['status:analyzed']; // Always add to prevent duplicate runs

  // Category to area label mapping
  const categoryToArea: Record<string, string> = {
    runtime_error: 'area:runtime',
    logic_error: 'area:logic',
    performance: 'area:performance',
    security: 'area:security',
    ui_ux: 'area:ui-ux',
    configuration: 'area:config',
  };

  // Handle invalid reports
  if (!analysis.isValidReport) {
    labelsToAdd.push('type:invalid', 'status:needs-info');
    console.log('   ğŸ“‹ Report marked as invalid/insufficient');
  } else {
    // Add labels based on report type
    switch (analysis.reportType) {
      case 'bug':
        labelsToAdd.push('type:bug');

        // Collect unique severities and areas from all analyses
        const severities = new Set<string>();
        const areas = new Set<string>();
        let hasVerifiedBug = false;
        let hasUnverifiedBug = false;

        for (const rootCauseAnalysis of analysis.analyses) {
          // Add severity label (use highest severity found)
          if (rootCauseAnalysis.severity && rootCauseAnalysis.severity !== 'none') {
            severities.add(`severity:${rootCauseAnalysis.severity}`);
          }

          // Add area label based on category
          const areaLabel = categoryToArea[rootCauseAnalysis.category];
          if (areaLabel) {
            areas.add(areaLabel);
          }

          // Track verification status
          if (rootCauseAnalysis.codeVerification?.bugExistsInCode) {
            hasVerifiedBug = true;
          } else {
            hasUnverifiedBug = true;
          }
        }

        // Add highest severity (priority order: critical > high > medium > low)
        const severityPriority = ['severity:critical', 'severity:high', 'severity:medium', 'severity:low'];
        for (const sev of severityPriority) {
          if (severities.has(sev)) {
            labelsToAdd.push(sev);
            break; // Only add highest severity
          }
        }

        // Add all unique areas (can have multiple affected areas)
        areas.forEach(area => labelsToAdd.push(area));

        // Add AI verification status
        if (hasVerifiedBug) {
          labelsToAdd.push('ai:verified');
        } else if (hasUnverifiedBug) {
          labelsToAdd.push('ai:unverified');
        }

        // Add label for multiple root causes
        if (analysis.analyses.length > 1) {
          labelsToAdd.push('multi-cause');
        }
        break;

      case 'not_a_bug':
        labelsToAdd.push('type:invalid', 'resolution:not-a-bug');
        break;

      case 'feature_request':
        labelsToAdd.push('type:enhancement', 'kind:feature');
        break;

      case 'improvement':
        labelsToAdd.push('type:enhancement', 'kind:improvement');
        break;

      case 'cannot_verify':
        labelsToAdd.push('type:bug', 'status:needs-repro', 'ai:unverified');
        break;

      case 'needs_info':
        labelsToAdd.push('status:needs-info');
        break;
    }
  }

  // Add labels (filter out duplicates)
  const uniqueLabels = [...new Set(labelsToAdd)];

  // Label color definitions (GitHub-style hex colors without #)
  // Design principles:
  // - Type: distinct primary colors
  // - Severity: traffic light (redâ†’orangeâ†’yellowâ†’green)
  // - Area: each has unique, meaningful color
  // - Status: professional blues and purples
  // - AI: trust indicator (blue=verified, gray=unverified)
  const labelColors: Record<string, { color: string; description: string }> = {
    // Type labels - Primary colors for instant recognition
    'type:bug': { color: 'FF0000', description: 'Something isn\'t working' },           // Pure red - danger
    'type:enhancement': { color: '0066FF', description: 'New feature or request' },     // Blue - new idea
    'type:invalid': { color: 'CCCCCC', description: 'Invalid or incomplete report' },   // Gray - dismissed

    // Severity labels - Traffic light system (instantly recognizable)
    'severity:critical': { color: '8B0000', description: 'Critical: System down or data loss' },  // Dark red - emergency
    'severity:high': { color: 'FF4500', description: 'High: Major functionality broken' },        // Orange red - urgent
    'severity:medium': { color: 'FFA500', description: 'Medium: Minor functionality issue' },     // Orange - attention
    'severity:low': { color: '32CD32', description: 'Low: Cosmetic or minor issue' },             // Lime green - minor

    // Area labels - Unique colors representing the domain
    'area:runtime': { color: '8B008B', description: 'Runtime errors and crashes' },      // Dark magenta - runtime crash
    'area:logic': { color: '9932CC', description: 'Logic errors and wrong behavior' },   // Purple - logic/brain
    'area:performance': { color: 'FF8C00', description: 'Performance issues' },          // Dark orange - speed warning
    'area:security': { color: 'DC143C', description: 'Security vulnerabilities' },       // Crimson - security alert
    'area:ui-ux': { color: '1E90FF', description: 'UI/UX issues' },                       // Dodger blue - UI/design
    'area:config': { color: '708090', description: 'Configuration issues' },             // Slate gray - settings/config

    // Status labels - Progress indicator colors
    'status:analyzing': { color: 'FFA500', description: 'AI analysis in progress' },     // Orange - in progress
    'status:analyzed': { color: '006400', description: 'AI analysis complete' },         // Dark green - done
    'status:needs-info': { color: 'FF69B4', description: 'More information needed' },    // Hot pink - needs attention
    'status:needs-repro': { color: 'FFD700', description: 'Reproduction steps needed' }, // Gold - warning/wait

    // AI verification labels - Trust indicator
    'ai:verified': { color: '228B22', description: 'Bug verified in code by AI' },       // Forest green - confirmed
    'ai:unverified': { color: 'A9A9A9', description: 'Needs manual verification' },      // Dark gray - uncertain

    // Resolution labels
    'resolution:not-a-bug': { color: 'E0E0E0', description: 'Not a bug - working as intended' },  // Light gray - closed

    // Kind labels - Feature types
    'kind:feature': { color: '00CED1', description: 'Feature request' },                 // Dark turquoise - new feature
    'kind:improvement': { color: '20B2AA', description: 'Improvement suggestion' },      // Light sea green - enhance

    // Multiple causes indicator
    'multi-cause': { color: 'FF6347', description: 'Multiple root causes identified' }, // Tomato - complex issue
  };

  // Ensure labels exist with correct colors
  if (uniqueLabels.length > 0) {
    console.log('   Creating/updating labels if needed...');
    for (const labelName of uniqueLabels) {
      const labelDef = labelColors[labelName];
      if (labelDef) {
        try {
          // Try to update the label (creates if doesn't exist)
          await octokit.issues.updateLabel({
            owner: config.owner,
            repo: config.repo,
            name: labelName,
            color: labelDef.color,
            description: labelDef.description,
          });
        } catch {
          // Label doesn't exist, create it
          try {
            await octokit.issues.createLabel({
              owner: config.owner,
              repo: config.repo,
              name: labelName,
              color: labelDef.color,
              description: labelDef.description,
            });
            console.log(`   Created label: ${labelName}`);
          } catch {
            // Label might already exist, ignore
          }
        }
      }
    }

    // Add labels to the issue
    try {
      await octokit.issues.addLabels({
        owner: config.owner,
        repo: config.repo,
        issue_number: config.issueNumber,
        labels: uniqueLabels,
      });
      console.log(`   âœ… Added labels: ${uniqueLabels.join(', ')}`);
    } catch {
      console.log('   âš ï¸ Could not add labels');
    }

    // Remove 'status:analyzing' label (lock release) - analysis is complete
    try {
      await octokit.issues.removeLabel({
        owner: config.owner,
        repo: config.repo,
        issue_number: config.issueNumber,
        name: 'status:analyzing',
      });
      console.log('   ğŸ”“ Removed status:analyzing label (lock released)');
    } catch {
      // Label might not exist, ignore
    }
  }

  console.log('\nâœ… Analysis complete!');
  console.log(`ğŸ”— https://github.com/${config.owner}/${config.repo}/issues/${config.issueNumber}`);
}

// ============================================
// Execute
// ============================================

analyzeIssue().catch((error) => {
  console.error('\nâŒ Analysis failed:', error instanceof Error ? error.message : error);
  process.exit(1);
});
