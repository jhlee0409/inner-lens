{"version":3,"sources":["../src/utils/session-replay.ts"],"names":[],"mappings":"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","file":"replay.js","sourcesContent":["/**\n * Session Replay Module using rrweb\n *\n * Provides consistent, framework-agnostic session recording\n * that captures DOM state regardless of console logging practices.\n */\n\nimport type { eventWithTime, recordOptions } from 'rrweb';\nimport type { listenerHandler } from '@rrweb/types';\n\n/**\n * Session replay configuration options\n */\nexport interface SessionReplayConfig {\n  /**\n   * Maximum duration to keep in buffer (in ms)\n   * @default 60000 (1 minute)\n   */\n  maxBufferDuration?: number;\n\n  /**\n   * Checkout interval for creating new snapshots (in ms)\n   * @default 30000 (30 seconds)\n   */\n  checkoutInterval?: number;\n\n  /**\n   * Enable/disable input masking for privacy\n   * @default true\n   */\n  maskInputs?: boolean;\n\n  /**\n   * CSS selectors for elements to block (hide completely)\n   */\n  blockSelectors?: string[];\n\n  /**\n   * CSS selectors for elements to mask (show placeholder)\n   */\n  maskSelectors?: string[];\n\n  /**\n   * Sampling configuration to reduce data size\n   */\n  sampling?: {\n    mousemove?: boolean | number;\n    mouseInteraction?: boolean;\n    scroll?: number;\n    media?: number;\n    input?: 'last' | 'all';\n  };\n\n  /**\n   * Callback when recording starts\n   */\n  onStart?: () => void;\n\n  /**\n   * Callback when recording stops\n   */\n  onStop?: () => void;\n\n  /**\n   * Callback on error\n   */\n  onError?: (error: Error) => void;\n}\n\n/**\n * Session replay data structure\n */\nexport interface SessionReplayData {\n  /**\n   * rrweb events array\n   */\n  events: eventWithTime[];\n\n  /**\n   * Recording start timestamp\n   */\n  startTime: number;\n\n  /**\n   * Recording end timestamp\n   */\n  endTime: number;\n\n  /**\n   * Duration in milliseconds\n   */\n  duration: number;\n\n  /**\n   * Approximate size in bytes\n   */\n  sizeBytes: number;\n\n  /**\n   * Number of events captured\n   */\n  eventCount: number;\n}\n\n/**\n * Session replay state\n */\ntype ReplayState = 'idle' | 'recording' | 'paused' | 'error';\n\n// Module state\nlet currentState: ReplayState = 'idle';\nlet stopFn: listenerHandler | null = null;\nlet eventsBuffer: eventWithTime[][] = [[]];\nlet recordingStartTime: number | null = null;\nlet config: Required<SessionReplayConfig>;\n\n// Default configuration\nconst DEFAULT_CONFIG: Required<SessionReplayConfig> = {\n  maxBufferDuration: 60000,\n  checkoutInterval: 30000,\n  maskInputs: true,\n  blockSelectors: [],\n  maskSelectors: ['.sensitive', '[data-sensitive]', '.pii'],\n  sampling: {\n    mousemove: 50, // Sample every 50ms\n    mouseInteraction: true,\n    scroll: 150, // Sample every 150ms\n    media: 800,\n    input: 'last',\n  },\n  onStart: () => {},\n  onStop: () => {},\n  onError: () => {},\n};\n\n/**\n * Dynamically imports rrweb to support tree-shaking\n */\nasync function loadRrweb() {\n  try {\n    const rrweb = await import('rrweb');\n    return rrweb;\n  } catch (error) {\n    throw new Error(\n      'Failed to load rrweb. Make sure it is installed: npm install rrweb'\n    );\n  }\n}\n\n/**\n * Initialize and start session recording\n */\nexport async function startSessionReplay(\n  userConfig: SessionReplayConfig = {}\n): Promise<void> {\n  if (typeof window === 'undefined') {\n    console.warn('Session replay is only available in browser environment');\n    return;\n  }\n\n  if (currentState === 'recording') {\n    console.warn('Session replay is already recording');\n    return;\n  }\n\n  config = { ...DEFAULT_CONFIG, ...userConfig };\n\n  try {\n    const { record } = await loadRrweb();\n\n    eventsBuffer = [[]];\n    recordingStartTime = Date.now();\n    currentState = 'recording';\n\n    const recordOptions: recordOptions<eventWithTime> = {\n      emit: (event: eventWithTime, isCheckout?: boolean) => {\n        if (isCheckout) {\n          // Start new events array on checkout\n          eventsBuffer.push([]);\n          // Keep only recent buffers based on maxBufferDuration\n          const maxBuffers = Math.ceil(\n            config.maxBufferDuration / config.checkoutInterval\n          );\n          if (eventsBuffer.length > maxBuffers + 1) {\n            eventsBuffer.shift();\n          }\n        }\n        const currentBuffer = eventsBuffer[eventsBuffer.length - 1];\n        if (currentBuffer) {\n          currentBuffer.push(event);\n        }\n      },\n      checkoutEveryNms: config.checkoutInterval,\n      maskAllInputs: config.maskInputs,\n      blockSelector: config.blockSelectors.join(', ') || undefined,\n      maskTextSelector: config.maskSelectors.join(', ') || undefined,\n      sampling: config.sampling,\n      // Privacy: don't record cross-origin iframes\n      recordCrossOriginIframes: false,\n      // Collect fonts for accurate replay\n      collectFonts: true,\n      // Inline styles for self-contained replay\n      inlineStylesheet: true,\n      // Inline images as base64 (careful with size)\n      inlineImages: false,\n    };\n\n    stopFn = record(recordOptions) ?? null;\n    config.onStart();\n  } catch (error) {\n    currentState = 'error';\n    const err = error instanceof Error ? error : new Error(String(error));\n    config.onError(err);\n    throw err;\n  }\n}\n\n/**\n * Stop session recording and return captured data\n */\nexport function stopSessionReplay(): SessionReplayData | null {\n  if (currentState !== 'recording' || !stopFn) {\n    console.warn('Session replay is not recording');\n    return null;\n  }\n\n  stopFn();\n  stopFn = null;\n  currentState = 'idle';\n\n  const endTime = Date.now();\n  const events = eventsBuffer.flat();\n  const eventsJson = JSON.stringify(events);\n\n  const data: SessionReplayData = {\n    events,\n    startTime: recordingStartTime ?? endTime,\n    endTime,\n    duration: endTime - (recordingStartTime ?? endTime),\n    sizeBytes: new Blob([eventsJson]).size,\n    eventCount: events.length,\n  };\n\n  config.onStop();\n  recordingStartTime = null;\n  eventsBuffer = [[]];\n\n  return data;\n}\n\n/**\n * Get current session replay data without stopping\n */\nexport function getSessionReplaySnapshot(): SessionReplayData | null {\n  if (currentState !== 'recording') {\n    return null;\n  }\n\n  const now = Date.now();\n  const events = eventsBuffer.flat();\n  const eventsJson = JSON.stringify(events);\n\n  return {\n    events,\n    startTime: recordingStartTime ?? now,\n    endTime: now,\n    duration: now - (recordingStartTime ?? now),\n    sizeBytes: new Blob([eventsJson]).size,\n    eventCount: events.length,\n  };\n}\n\n/**\n * Check if session replay is currently recording\n */\nexport function isRecording(): boolean {\n  return currentState === 'recording';\n}\n\n/**\n * Get current recording state\n */\nexport function getRecordingState(): ReplayState {\n  return currentState;\n}\n\n/**\n * Compress events data for transmission\n * Uses browser's built-in CompressionStream if available\n */\nexport async function compressReplayData(\n  data: SessionReplayData\n): Promise<Blob> {\n  const jsonString = JSON.stringify(data.events);\n  const blob = new Blob([jsonString], { type: 'application/json' });\n\n  // Check for CompressionStream support\n  if (typeof CompressionStream !== 'undefined') {\n    const stream = blob.stream().pipeThrough(new CompressionStream('gzip'));\n    return new Response(stream).blob();\n  }\n\n  // Fallback: return uncompressed\n  return blob;\n}\n\n/**\n * Create a replay player URL (for debugging)\n * Encodes events as base64 in URL hash\n */\nexport function createReplayUrl(data: SessionReplayData): string {\n  const eventsJson = JSON.stringify(data.events);\n\n  // For small replays, encode in URL\n  if (eventsJson.length < 50000) {\n    const encoded = btoa(encodeURIComponent(eventsJson));\n    return `https://rrweb.io/player?events=${encoded}`;\n  }\n\n  // For larger replays, suggest using the player separately\n  return 'https://rrweb.io/player (events too large for URL)';\n}\n\n/**\n * Estimate quality score based on captured data\n */\nexport function calculateReplayQualityScore(data: SessionReplayData): {\n  score: number;\n  factors: Record<string, { value: number; weight: number }>;\n} {\n  const factors: Record<string, { value: number; weight: number }> = {\n    hasFullSnapshot: {\n      value: data.events.some((e) => e.type === 2) ? 100 : 0, // type 2 = FullSnapshot\n      weight: 0.3,\n    },\n    hasMutations: {\n      value: data.events.some((e) => e.type === 3) ? 100 : 50, // type 3 = IncrementalSnapshot\n      weight: 0.2,\n    },\n    hasUserInteractions: {\n      value:\n        data.events.filter(\n          (e) =>\n            e.type === 3 &&\n            (e.data as { source?: number }).source !== undefined &&\n            [1, 2, 5].includes((e.data as { source: number }).source) // MouseInteraction, Scroll, Input\n        ).length > 0\n          ? 100\n          : 30,\n      weight: 0.25,\n    },\n    duration: {\n      value: Math.min(100, (data.duration / 5000) * 100), // 5+ seconds = full score\n      weight: 0.15,\n    },\n    eventDensity: {\n      value: Math.min(100, (data.eventCount / 50) * 100), // 50+ events = full score\n      weight: 0.1,\n    },\n  };\n\n  const score = Object.values(factors).reduce(\n    (sum, f) => sum + f.value * f.weight,\n    0\n  );\n\n  return { score: Math.round(score), factors };\n}\n\n// Export types\nexport type { eventWithTime } from 'rrweb';\n"]}